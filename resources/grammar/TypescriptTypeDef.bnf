{

	tokens = [

		INTERFACE = 'interface';
		VAR = "var";
		DECLARE = "declare";
		CONST = "const";
		EXTENDS = "extends"
		READONLY = "readonly"
		FUNCTION_KEYWORD = "function"
		VOID = "void"
		WHITE_SPACE = "regexp:\s+";
		SINGLE_LINE_COMMENT = "regexp://[^\n]*\n?";
		BLOCK_COMMENT = "regexp:/\*(([^*]|\*[^/])*?(?=\*/))\*/";
		DOUBLE_QUOTE = 'regexp:"([^"]|\\")*"';
		SINGLE_QUOTE = "regexp:'([^']|\\')*'";
		TYPE = "type"
		KEYOF = "keyof"
		INTERSECT = '&'
		ELIPSIS = "..."

		FUNCTION_ARROW = "=>";
		LT = "<";
		GT = ">";
		DASH = "-";
		EQ = "=";
		CLOSE_ELEMENT = "/>";
		COLON = ":";
		COMMA = ","
		SEMI_COLON = ";";
		OPEN_BRACE = "{";
		CLOSE_BRACE = "}";
		OPEN_PAREN = "(";
		CLOSE_PAREN = ")";
		OPT_SEPERATOR = "|";
		DASH_LITERAL = "regexp:[a-zA-Z][a-zA-Z_0-9]*(-([a-zA-Z_0-9]*))+";
		ID = "regexp:[_$a-zA-Z][a-zA-Z_0-9]*";
		OPEN_BRACKET = '['
		CLOSE_BRACKET = ']'
		QUESTION_MARK = '?'

	]
}

definition ::= (!<<eof>> statement)*

statement
	::= constDeclaration
	|	interfaceDeclaration
	|	varDeclaration
	| 	functionDeclaration
	| 	keyMap
	;

interfaceDeclaration
	::= 'interface' interfaceHeader '{' interfaceDeclarationProperties? '}'
	{
		pin=2
	}
	;

interfaceHeader
	::= className headerGenericParam? extendsHeaderPart?
	;

headerGenericParam
	::= '<' genericParams '>'
	{
		pin = 1
	}
	;

genericParams
	::= genericParam (',' genericParam)*
	;

genericParam
	::= ID '=' className
	;

extendsHeaderPart
	::= 'extends' classNamesList
	{
		pin=1
	}
	;

private classNamesList
	::= className (',' className)*
	{
		//recoverWhile=classNamesList_recover
	}
	;

interfaceDeclarationProperties
	::= interfaceProperty+
	;

interfaceProperty
	::= function
	|	property
	;

property
	::= 'readonly'?  propertyBase ';'
	{
		pin=2
	}
	;

propertyBase
	::= (namedArg | propertyDef | parenDef | string) '?'? ':' variableTypeList
	{
		pin=3
	}
	;

constDeclaration
	::= 'declare' 'const' propertyBase ';'
	{
		pin=2
	}
	;

functionProperty
	::= namedArg? '(' (propertyBase (',' propertyBase)*)? ')' '=>' variableTypeList
	{
		pin=2
	}
	;

functionKeyOf
	::= '<' className 'extends' KEYOF keyMapName '>'
	{
		pin = 4
	}
	;

propertyDef
	::= '[' namedArg ':' className ']'
	;

parenDef
	::= '(' namedArg ':' className ')'
	;

function
	::= functionName? functionGenerics? '?'? '(' functionArgs? ')' functionReturn? ';'
	{
		pin=2
	}
	;

functionGenerics
	::= genericParameters
	| functionKeyOf
	;

private functionReturn
	::= ':' returnType
	{
		pin=1
	}
	;

functionArgs
	::= functionArg (',' functionArg)*
	{
		recoverWhile=functionArgs_recover
	}
	;

private functionArgs_recover
	::= !(")")
	;

functionArg
	::=  namedArg COLON variableTypeList
	{
		pin = 2
	}
	;

arrayBrackets
	::= '[' className? ']'
	;

functionName
	::= ID
	;

keyMap
	::= 'declare' 'type' keyMapName '=' keymapType ('|' keymapType)* ';'
	{
		pin = 2
	}
	;

keymapType
	::= string | className
	;

namedArg
	::= '...'? (ID|'type') '?'?
	;

variableTypeList
	::= variableTypeListInternal
	;

private variableTypeListInternal
	::= variableType ('|' variableType)*
	;

variableType
	::= objectLiteral
	|	variableTypeIntersect
	|	functionProperty
	|	variableTypePrime variableTail?
	| 	'void'
	;

variableTypeIntersect
	::=	variableTypePrime ('&' variableTypePrime)
	;

variableTypePrime
	::=	'(' variableType ')'
	|	'(' variableTypeList ')'
	|	className
	|	string
	| 	'type'
	;

variableTail
	::= arrayBrackets
	| 	genericParameters
	;

genericParameters
	::= '<' classNamesList '>'
	;

returnType
	::= variableType ('|' variableType)*
	;


genericClassNameParams
	::= '<' (className (',' className)*)? '>'
	{
		pin = 2
	}
	;

className
	::= ID extendsProperty
	|	ID genericClassNameParams?
	| 'void'
	{
		pin(".*")=2
	}
	;

genericClassType
	::= className extendsProperty?
	{
		pin=2
	}
	;

private extendsProperty
	::= 'extends' variableType
	{
		pin=1
	}
	;


variableName
	::= ID
	;

varDeclaration
	::= 'declare' 'var' variableName ':' varType ';'
	;

functionDeclaration
	::= 'declare' 'function' function
	;

string
	::= SINGLE_QUOTE
	| 	DOUBLE_QUOTE
	;

keyMapName
	::= ID
	;

varType
	::= objectLiteral
	|	className
	;

objectLiteral
	::= '{' objectLiteralProperties? '}'
	;

private objectLiteralProperties
	::= objectLiteralProperty (',' objectLiteralProperty)*
	;

objectLiteralProperty
	::= property
	| 	function
	;

