{

	tokens = [

		INTERFACE = 'interface';
		VAR = "var";
		DECLARE = "declare";
		CONST = "const";
		EXTENDS = "extends"
		READONLY = "readonly"
		FUNCTION_KEYWORD = "function"
		VOID = "void"
		WHITE_SPACE = "regexp:\s+";
		SINGLE_LINE_COMMENT = "regexp://[^\n]*\n?";
		BLOCK_COMMENT = "regexp:/\*(([^*]|\*[^/])*?(?=\*/))\*/";
		DOUBLE_QUOTE = 'regexp:"([^"]|\\")*"';
		SINGLE_QUOTE = "regexp:'([^']|\\')*'";
		TYPE = "type"
		KEYOF = "keyof"
		INTERSECT = '&'
		ELIPSIS = "..."

		FUNCTION_ARROW = "=>";
		LT = "<";
		GT = ">";
		DASH = "-";
		EQ = "=";
		CLOSE_ELEMENT = "/>";
		COLON = ":";
		COMMA = ","
		SEMI_COLON = ";";
		OPEN_BRACE = "{";
		CLOSE_BRACE = "}";
		OPEN_PAREN = "(";
		CLOSE_PAREN = ")";
		OPT_SEPERATOR = "|";
		DASH_LITERAL = "regexp:[a-zA-Z][a-zA-Z_0-9]*(-([a-zA-Z_0-9]*))+";
		ID = "regexp:[_$a-zA-Z][a-zA-Z_0-9]*";
		OPEN_BRACKET = '['
		CLOSE_BRACKET = ']'
		QUESTION_MARK = '?'

	]
}

definition ::= (!<<eof>> statement)*

statement
	::= constDeclaration
	|	interfaceDeclaration
	|	varDeclaration
	| 	functionDeclaration
	| 	keyMap
	;

interfaceDeclaration
	::= 'interface' interfaceHeader '{' interfaceDeclarationProperties? '}'
	{
		pin=2
	}
	;

interfaceHeader
	::= className headerGenericParam? extendsHeaderPart?
	;

headerGenericParam
	::= '<' genericParams '>'
	{
		pin = 1
	}
	;

genericParams
	::= genericParam (',' genericParam)*
	;

genericParam
	::= genericClassType ('|' genericClassType)*
	;

extendsHeaderPart
	::= 'extends' classNamesList
	{
		pin=1
	}
	;

private classNamesList
	::= classType (',' classType)*
	{
		//recoverWhile=classNamesList_recover
	}
	;

interfaceDeclarationProperties
	::= interfaceProperty+
	;

interfaceProperty
	::= function  ';'
	|	'readonly'?  property ';'
	;

property
	::= (namedArg | propertyDef | parenDef | string) '?'? ':' variableTypeList
	{
		pin=3
	}
	;

constDeclaration
	::= 'declare' 'const' property ';'
	{
		pin=2
	}
	;

functionProperty
	::= namedArg? '(' (property (',' property)*)? ')' '=>' variableTypeList
	;

functionKeyOf
	::= '<' className 'extends' KEYOF keyMapName '>'
	{
		pin = 4
	}
	;

propertyDef
	::= '[' namedArg ':' className ']'
	;

parenDef
	::= '(' namedArg ':' className ')'
	;

function
	::= (functionName functionGenerics? '?'?)? '(' functionArgs? ')' functionReturn?
	{
		pin=2
		recoverWhile=function_recover
	}
	;
private function_recover
	::= !(';')
	;

functionGenerics
	::= genericParameters
	| functionKeyOf
	;

private functionReturn
	::= ':' returnType
	{
		pin=1
	}
	;

functionArgs
	::= functionArg (',' functionArg)*
	{
		recoverWhile=functionArgs_recover
	}
	;

private functionArgs_recover
	::= !(")")
	;

functionArg
	::=  namedArg COLON variableTypeList
	{
		pin = 2
	}
	;

arrayBrackets
	::= '[' className? ']'
	;

functionName
	::= ID
	;

keyMap
	::= 'declare' 'type' keyMapName '=' keymapType ('|' keymapType)* ';'
	{
		pin = 2
	}
	;

keymapType
	::= string | className
	;

namedArg
	::= '...'? (ID | 'type' | 'extends') '?'?
	;

variableTypeList
	::= variableTypeListInternal
	;

private variableTypeListInternal
	::= variableType ('|' variableType)*
	;

variableType
	::= paramObjectType
	|	variableTypeIntersect
	|	functionProperty
	|	variableTypePrime variableTail?
	| 	'void'
	;

variableTypeIntersect
	::=	classType ('&' classType)
	;

variableTypePrime
	::=	'(' variableType ')'
	|	'(' variableTypeList ')'
	|	classType
	|	string
	| 	'type'
	;

variableTail
	::= arrayBrackets
	| 	genericParameters
	;

genericParameters
	::= '<' classNamesList '>'
	;

returnType
	::= variableType ('|' variableType)*
	;


genericClassNameParams
	::= '<' (genericClassType (',' genericClassType)*)? '>'
	{
		pin = 2
	}
	;

genericClassType
	::= typeAlias
	|	classType
	{
		pin=2
	}
	;

classType
	::= className extendsProperty
	|	className genericClassNameParams
	|	className
	;


className
	::= ID | 'void'
	;

private extendsProperty
	::= 'extends' variableType
	{
		pin=1
	}
	;

typeAlias
	::= className '=' className
	;

variableName
	::= ID
	;

varDeclaration
	::= 'declare' 'var' variableName ':' (objectLiteral|variableType) ';'
	{
		pin=2
	}
	;

functionDeclaration
	::= 'declare' 'function' function  ';'
	;

string
	::= SINGLE_QUOTE
	| 	DOUBLE_QUOTE
	;

keyMapName
	::= ID
	;

paramObjectType
	::= '{' ( objectLiteralProperty (',' objectLiteralProperty)*) '}'
	{
		pin=2
	}
	;

objectLiteral
	::= '{' objectLiteralProperties? '}'
	{
		pin=2
	}
	;

private objectLiteralProperties
	::= interfaceProperty*
	;

objectLiteralProperty
	::= property
	| 	function
	;



