{

	tokens = [

		INTERFACE = 'interface';
		VAR = "var";
		DECLARE = "declare";
		CONST = "const";
		EXTENDS = "extends"
		READONLY = "readonly"
		FUNCTION_KEYWORD = "function"
		VOID = "void"
		WHITE_SPACE = "regexp:\s+";
		SINGLE_LINE_COMMENT = "regexp://[^\n]*\n?";
		BLOCK_COMMENT = "regexp:/\*(([^*]|\*[^/])*?(?=\*/))\*/";
		DOUBLE_QUOTE = 'regexp:"([^"]|\\")*"';
		SINGLE_QUOTE = "regexp:'([^']|\\')*'";
		TYPE = "TYPE"
		KEYOF = "KEYOF"
		NEW_KEYWORD = "new"

		FUNCTION_ARROW = "=>";
		LT = "<";
		GT = ">";
		DASH = "-";
		EQ = "=";
		CLOSE_ELEMENT = "/>";
		COLON = ":";
		COMMA = ","
		SEMI_COLON = ";";
		OPEN_BRACE = "{";
		CLOSE_BRACE = "}";
		OPEN_PAREN = "(";
		CLOSE_PAREN = ")";
		OPT_SEPERATOR = "|";
		DASH_LITERAL = "regexp:[a-zA-Z][a-zA-Z_0-9]*(-([a-zA-Z_0-9]*))+";
		ID = "regexp:[_$a-zA-Z][a-zA-Z_0-9]*";
		OPTIONAL_ID = "regexp:[_$a-zA-Z][a-zA-Z_0-9]*\?";
		OPEN_BRACKET = '['
		CLOSE_BRACKET = ']'
		QUESTION_MARK = '?'

	]
}

definition ::= (!<<eof>> statement)*

statement
	::= interfaceDeclaration
	|	varDeclaration
	| 	functionDeclaration
	| 	keyMap
	;

interfaceDeclaration
	::= 'interface' interfaceHeader '{' interfaceDeclarationProperties? '}'
	{
		pin=2
	}
	;

interfaceHeader
	::= className headerGenericParam? extendsHeaderPart?
	;

headerGenericParam
	::= '<' genericParams '>'
	{
		pin = 1
	}
	;

genericParams
	::= genericParam (',' genericParam)*
	;

genericParam
	::= ID '=' className
	;

extendsHeaderPart
	::= 'extends' classNamesList
	{
		pin=1
	}
	;

private classNamesList
	::= className (',' className)*
	{
		//recoverWhile=classNamesList_recover
	}
	;

private classNamesList_recover
	::= !('{')
	;

interfaceDeclarationProperties
	::= interfaceProperty+
	;

interfaceProperty
	::= property
	| 	function
	;

property
	::= 'readonly'?  propertyBase ';'
	{
		pin=2
	}
	;

propertyBase
	::= (namedArg | propertyDef | parenDef | string) '?'? ':' variableTypeList
	;

functionProperty
	::= '(' (propertyBase (',' propertyBase)*)? ')' '=>' variableTypeList
	;

functionKeyOf
	::= '<' className 'extends' KEYOF keyMapName '>'
	;

propertyDef
	::= '[' namedArg ':' className ']'
	;

parenDef
	::= '(' namedArg ':' className ')'
	;

function
	::= functionName functionKeyOf? '(' functionArgs? ')' functionReturn? ';'
	{
		pin=2
	}
	;

private functionReturn
	::= ':' returnType
	{
		pin=1
	}
	;

functionArgs
	::= functionArg (',' functionArg)*
	{
		recoverWhile=functionArgs_recover
	}
	;

private functionArgs_recover
	::= !(")")
	;

functionArg
	::=  namedArg COLON variableTypeList
	;

arrayBrackets
	::= '[' className? ']'
	;

functionName
	::= ID
	;

keyMap
	::= 'TYPE' keyMapName '=' string ('|' string)*
	;

namedArg
	::= (ID|OPTIONAL_ID|'TYPE')
	;

variableTypeList
	::= variableTypeListInternal
	;

private variableTypeListInternal
	::= variableType ('|' variableType)*
	;

variableType
	::= '(' variableType ')' variableTail?
	|	'(' variableTypeList ')' variableTail?
	|	className variableTail?
	| 	'void'
	|	functionProperty
	|	string
	| 	'TYPE'
	| 	objectLiteral
	;

variableTail
	::= arrayBrackets | genericParameters
	;

genericParameters
	::= '<' classNamesList '>'
	;

returnType
	::= variableType ('|' variableType)*
	;

className
	::= ID genericClassNameParams?
	| 'void'
	;

genericClassNameParams
	::= '<' (className (',' className)*)? '>'
	;

variableName
	::= ID
	;

varDeclaration
	::= 'declare' 'var' variableName ':' varType ';'
	;

functionDeclaration
	::= 'declare' 'function' function
	;

string
	::= SINGLE_QUOTE
	| 	DOUBLE_QUOTE
	;

keyMapName
	::= ID
	;

varType
	::= objectLiteral
	|	className
	;

objectLiteral
	::= '{' objectLiteralProperties? '}'
	;

private objectLiteralProperties
	::= objectLiteralProperty (',' objectLiteralProperty)*
	;

objectLiteralProperty
	::= property
	| 	function
	;

