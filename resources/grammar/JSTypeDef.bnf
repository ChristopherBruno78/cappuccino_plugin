{

	tokens = [

		INSTANCE = 'instance';
		VAR = "var";
		GLOBAL = "global";
		EXTENDS = "extends"
		READONLY = "readonly"
		FUNCTION_KEYWORD = "function"
		const = "const"
		TYPE = 'type'
		NAMESPACE = "namespace"
		WHITE_SPACE = "regexp:\s+";
		SINGLE_LINE_COMMENT = "regexp://[^\n]*\n?";
		BLOCK_COMMENT = "regexp:/\*(([^*]|\*[^/])*?(?=\*/))\*/";
		DOUBLE_QUOTE = 'regexp:"([^"]|\\")*"';
		SINGLE_QUOTE = "regexp:'([^']|\\')*'";
		TYPE = "type"
		KEYOF = "keyof"
		INTERSECT = '&'
		ELIPSIS = "..."
		OBJECT = "object"
		IS_KEYWORD = 'is'
		KEYMAP = 'keymap'
		KEYSET = 'keyset'
		IN = 'in'
		OF = 'of'
		WHEN = 'when';

		FUNCTION_ARROW = "->";
		LT = "<";
		GT = ">";
		DASH = "-";
		EQ = "=";
		CLOSE_ELEMENT = "/>";
		COLON = ":";
		COMMA = ","
		SEMI_COLON = ";";
		OPEN_BRACE = "{";
		CLOSE_BRACE = "}";
		OPEN_PAREN = "(";
		CLOSE_PAREN = ")";
		OPT_SEPERATOR = "|";
		DASH_LITERAL = "regexp:[a-zA-Z][a-zA-Z_0-9]*(-([a-zA-Z_0-9]*))+";
		ID = "regexp:[_$a-zA-Z][a-zA-Z_0-9]*";
		OPEN_BRACKET = '['
		CLOSE_BRACKET = ']'
		QUESTION_MARK = '?'
		DOT = '.'

	]
}

definition ::= (!<<eof>> statement)*

statement
	::= namespaceDec
	|	globalConst ';'
	|	globalFunction ';'
	|	globalObject
	|	instanceTypeAlias
	|	instanceType
	|	keymap
	|	keyset
	|	';'
	{
		pin(".*")=1
	}
	;

globalConst
	::= 'global' '<' 'const' '>' variableName '?'? ':' variableTypeList
	{
		pin=3
	}
	;

globalFunction
	::= 'global' '<' 'function' '>' functionProperty
	{
		pin=3
	}
	;

functionProperty
	::= functionName? genericClassList? '?'? '(' functionArgs? ')' ':' returnType
	{
		pin=4
	}
	;

private functionArgs
	::= functionArg (',' functionArg)*
	{
		pin(".*")=1
		recoverWhile=functionArgs_recover
	}
	;

functionArg
	::= keyMapWhen
	|	variableProperty
	;

keyMapWhen
	::= 'when' (variableName '=')? stringLiteral ('|' stringLiteral)*
	;

private functionArgs_recover
	::= !(')')
	;


instanceTypeAlias
	::= '=' '<' variableTypeList '>'
	;

instanceType
	::= 'instance' '<' 'object' '>' classDeclaration
	{
		pin(".*")=3
	}
	;


classDeclarationBody
	::= ':'? objectDeclaration
	|	instanceTypeAlias
	;

globalObject
	::= 'global' '<' 'object' '>' classDeclaration
	;

classDeclaration
	::= className extendsStatement? classDeclarationBody?
	{
		pin=1
	}
	;

objectDeclaration
	::= '{' objectDeclarationProperties? '}'
	{
		pin=1
	}
	;

private objectDeclarationProperties
	::= objectDeclarationProperty (',' objectDeclarationProperty)+
	|	objectDeclarationProperty (';' objectDeclarationProperty)+ ';'?
	|	objectDeclarationProperty ';'?
	{
		recoverWhile=objectDeclarationProperties_recover
	}
	;

private objectDeclarationProperty
	::= functionProperty
	|	variableProperty
	;

private objectDeclarationProperties_recover
	::= !("}")
	;

variableProperty
	::= 'readonly'? '...'? variableName '?'? ':' variableTypeList
	{
		pin=5
	}
	;

variableTypeList
	::= variableType ('|' variableType)+
	|	variableType
	;

variableType
	::= parenEnclosedType
	|	keyType
	|	functionVariableType
	|	stringLiteral
	|	objectDeclaration
	|	arrayType
	|	intersection
	| 	isClass
	|	className
	;

keyType
	::= '<' genericKey '>' 'of' keyMapName
	{
		pin = 4
	}
	;

isClass
	::= className 'is' className
	{
		pin=2
	}
	;


intersection
	::= className '&' className
	{
		pin=2
	}
	;

parenEnclosedType
	::= '(' variableType ')'
	{
		//pin=2
	}
	;

arrayType
	::=  arrayTypeTypes '[' ']' ('[' ']')*
	{
		pin=2;
	}
	;

private arrayTypeTypes
	::=	'(' className ('|'className)* ')'
	| 	className
	;


functionVariableType
	::= '(' functionArgs? ')' '->' returnType
	{
		pin=4
	}
	;

objectKey
	::= '[' variableProperty ']'
	{
		pin=2
	}
	;

keymap
	::= '<' 'keymap' '>' keyMapName keyMapExtension? '{'  keymapProps '}' ';'?
	;

keyMapExtension
	::= 'extends' keyMapName (',' keyMapName)*
	;

keymapProps
	::= keymapProp (';' keymapProp)* ';'?
	;

keyset
	::= '<' 'keyset' '>' keyMapName '=' stringLiteral ('|' stringLiteral)* ';'?
	;

keymapProp
	::= stringLiteral ':' variableTypeList
	;

extendsStatement
	::= 'extends' className (',' variableType)*
	|	':' variableTypeList
	{
		pin=1
	}
	;

returnType
	::= returnTypeFilter
	|	variableTypeList
	|	variableType returnTypeGenerics?
	;

returnTypeFilter
	::= variableName 'is' variableType
	;

returnTypeGenerics
	::= '<' className (',' className)? '>'
	;

functionName
	::= ID
	|	'of'
	;

className
	::= namespace? (/*<<inMode 'GENERIC_MODE'>> genericKey |*/ classNameElement) classNamePrime?
	{
		pin=2
	}
	;

namespaceDec
	::= 'namespace' '<' moduleName '>' '{' statement* '}'
	{
		pin=1
	}
	;

namespace
	::= (moduleName '.')+
	{
		pin(".*")=2
	}
	;

moduleName
	::= ID
	;

classNameElement
	::=	ID
	|	'object'
	;

private classNamePrime
	::= genericClassList
	{
		pin=1
	}
	;

genericClassList
	::= '<' genericClassDec (',' genericClassDec)* '>'
	{
		pin(".*")=1;
	}
	;

variableName
	::= objectKey
	|	ID
	|	'global'
	|	'type'
	|	'extends'
	|	'namespace'
	|	'when'
	|	'is'
	|	'object'
	|	'readonly'
	|	'of'
	|	stringLiteral
	;

genericClassDec
	::= genericKey genericExtendsStatementPrime
	|	genericKey genericTypeAlias
	|	genericKey genericKeyOf
	|	genericKey isClass
	|	/*<<enterMode 'GENERIC_MODE'>>*/ variableTypeList /*<<exitMode 'GENERIC_MODE'>>*/
	;

genericExtendsStatementPrime
	::= 'extends' variableTypeList
	;

genericTypeAlias
	::=	'=' className
	;

genericKeyOf
	::= 'in' keyMapName
	;

genericKey
	::= ID
	;

keyMapName
	::= ID
	;

stringLiteral
	::= DOUBLE_QUOTE
	|	SINGLE_QUOTE
	;