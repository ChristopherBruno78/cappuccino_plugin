{
	parserClass="cappuccino.ide.intellij.plugin.parser.ObjectiveJParser"
	parserUtilClass="cappuccino.ide.intellij.plugin.parser.ObjectiveJParserUtil"
	implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
	extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJCompositeElementImpl"
	elementTypeHolderClass="cappuccino.ide.intellij.plugin.psi.types.ObjJTypes"
	elementTypePrefix="ObjJ_"
	elementTypeClass="cappuccino.ide.intellij.plugin.psi.types.ObjJCompositeElementType"
	tokenTypeClass="cappuccino.ide.intellij.plugin.psi.types.ObjJTokenType"
	psiClassPrefix="ObjJ"
	psiImplClassSuffix="Impl"
	psiPackage="cappuccino.ide.intellij.plugin.psi"
	psiImplPackage="cappuccino.ide.intellij.plugin.psi.impl"
	generateTokenAccessors=true
	elementTypeFactory("implementationDeclaration|methodHeader|protocolDeclaration|instanceVariableDeclaration|accessorProperty|methodCall|selectorLiteral|functionDeclaration|functionLiteral|preprocessorDefineFunction|globalVariableDeclaration|importFile|importFramework|includeFile|includeFramework|varTypeId|variableName")="cappuccino.ide.intellij.plugin.psi.types.ObjJElementTypeFactory.factory"
	psiImplUtilClass="cappuccino.ide.intellij.plugin.psi.utils.ObjJPsiImplUtil"
	//Tokens
	tokens = [
		//Line Terminator
		LINE_TERMINATOR =                 	'regexp:[\r\n\u2028\u2029]'
		space = 							'regexp:\s+'
		//Symbols
		AT_OPENBRACKET = 					'@['
		OPEN_BRACKET =                    	'['
		CLOSE_BRACKET =                   	']'
		OPEN_PAREN =                      	'('
		CLOSE_PAREN =                     	')'
		OPEN_BRACE =                      	'{'
		CLOSE_BRACE =                     	'}'
		SEMI_COLON =                      	';'
		COMMA =                          	','
		ASSIGN =                         	'='
		QUESTION_MARK =                   	'?'
		COLON =                         	':'
		ELLIPSIS =                       	'...'
		DOT =                            	'.'
		PLUS_PLUS =                      	'++'
		MINUS_MINUS =                     	'--'
		PLUS =                           	'+'
		MINUS =                          	'-'
		BIT_NOT =                         	'~'
		NOT =                            	'!'
		MULTIPLY =                       	'*'
		DIVIDE =                         	'/'
		MODULUS =                        	'%'
		RIGHT_SHIFT_ARITHMATIC =           	'>>'
		LEFT_SHIFT_ARITHMATIC =            	'<<'
		RIGHT_SHIFT_LOGICAL =              	'>>>'
		LEFT_SHIFT_LOGICAL =             	'<<<'
		LESS_THAN =                       	'<'
		GREATER_THAN =                    	'>'
		LESS_THAN_EQUALS =                 	'<='
		GREATER_THAN_EQUALS =              	'>='
		EQUALS =                        	'=='
		NOT_EQUALS =                      	'!='
		IDENTITY__EQUALS =                 	'==='
		IDENTITY_NOT_EQUALS =              	'!=='
		BIT_AND =                         	'&'
		BIT_XOR =                         	'^'
		BIT_OR =                          	'|'
		AND =                            	'&&'
		OR =                             	'||'
		MULTIPLY_ASSIGN =                 	'*='
		DIVIDE_ASSIGN =                   	'/='
		MODULUS_ASSIGN =                  	'%='
		PLUS_ASSIGN =                     	'+='
		MINUS_ASSIGN =                    	'-='
		LEFT_SHIFT_ARITHMATIC_ASSIGN =      '<<='
		RIGHT_SHIFT_ARITHMATIC_ASSIGN =     '>>='
		LEFT_SHIFT_LOGICAL_ASSIGN =        '<<<='
		RIGHT_SHIFT_LOGICAL_ASSIGN =        '>>>='
		BIT_AND_ASSIGN =                   	'&='
		BIT_XOR_ASSIGN =                   	'^='
		BIT_OR_ASSIGN =                    	'|='
		ARROW =                          	'=>'
		DOUBLE_QUO =						'"'
		AT_DOUBLE_QUOTE	=					"@\""
		SINGLE_QUO = 						"'"
		BLOCK_COMMENT_START =				"/*"
		BLOCK_COMMENT_END =				 	"*/"


		// At Statements
		AT_IMPORT  = 						'@import'
		AT_ACCESSORS  = 					'@accessors'
		AT_END  = 							'@end'
		AT_ACTION  = 						'@action'
		AT_SELECTOR  = 						'@selector'
		AT_CLASS  = 						'@class'
		AT_GLOBAL  = 						'@global'
		AT_REF  = 							'@ref'
		AT_DEREF  = 						'@deref'
		AT_PROTOCOL  = 						'@protocol'
		AT_OPTIONAL  = 						'@optional'
		AT_REQUIRED = 						'@required'
		AT_INTERFACE  = 					'@interface'
		AT_TYPE_DEF  = 						'@typedef'
		AT_IMPLEMENTATION  = 				'@implementation'
		AT_OUTLET  = 						'@outlet'
		AT_OPEN_BRACE =						'@{'

		/// Null Literals
		NULL_LITERAL =                    	'null'
		NIL =								'nil'
		UNDEFINED=							'undefined'

		//Preprocessor
		PP_DEFINE = 						'#define'
		PP_UNDEF = 							'#undef'
		PP_IF_DEF = 						'#ifdef'
		PP_IF_NDEF = 						'#ifndef'
		PP_IF = 							'#if'
		PP_ELSE = 							'#else'
		PP_END_IF = 						'#endif'
		PP_ELSE_IF = 						'#elif'
		PP_PRAGMA = 						'#pragma'
		PP_DEFINED = 						'#defined'
		PP_ERROR = 							'#error'
		PP_WARNING = 						'#warning'
		PP_INCLUDE = 						'#include'

		//'var' Types
		//VAR_TYPE_ID = 					'id'
		VAR_TYPE_BYTE = 					'regexp:((unsigned|signed)[ ]+)?byte'
		VAR_TYPE_CHAR = 					'regexp:((unsigned|signed)[ ]+)?char'
		VAR_TYPE_SHORT = 					'regexp:((unsigned|signed)[ ]+)?short'
		VAR_TYPE_INT = 						'regexp:((unsigned|signed)[ ]+)?int'
		VAR_TYPE_LONG_LONG = 				'regexp:((unsigned|signed)[ ]+)?long[ ]+long'
		VAR_TYPE_LONG =						'regexp:((unsigned|signed)[ ]+)?long'
		VAR_TYPE_SIGNED =					'signed'
		VAR_TYPE_UNSIGNED = 				'unsigned'
		VAR_TYPE_IBACTION = 				'IBAction'
		VAR_TYPE_IBOUTLET = 				'IBOutlet'
		VAR_TYPE_SEL = 						'SEL'
		VAR_TYPE_FLOAT= 					'float'
		VAR_TYPE_DOUBLE= 					'double'
		VAR_TYPE_BOOL = 					'BOOL'
		IMPORT_FRAMEWORK_LITERAL = 			'regexp:<.*/.*>'
		//Keywords
		BREAK =                          	'break'
		DO =                             	'do'
		INSTANCE_OF =                     	'instanceof'
		TYPE_OF =                         	'typeof'
		CASE =                           	'case'
		ELSE =                           	'else'
		NEW =                            	'new'
		VAR =                            	'var'
		CATCH =                          	'catch'
		FINALLY =                        	'finally'
		RETURN =                        	'return'
		VOID =                           	'void'
		CONTINUE =                       	'continue'
		FOR =                            	'for'
		SWITCH =                         	'switch'
		WHILE =                          	'while'
		DEBUGGER =                       	'debugger'
		FUNCTION =                       	'function'
		THIS =                           	'this'
		WITH =                           	'with'
		DEFAULT =                        	'default'
		IF =                             	'if'
		THROW =                          	'throw'
		DELETE =                         	'delete'
		IN =                             	'in'
		TRY =                            	'try'
		//SUPER =                          	'super'
		LET = 								'let'
		CONST = 							'const'
		MARK = 								'mark'
		ERROR_SEQUENCE_TOKEN				'?*__ERR_SEMICOLON__*?'

		//Literals
		//SINGLE_QUOTE_STRING_LITERAL = 		"regexp:'([^'\\\r\n]|\\['\\bfnrtv])*'"
		//DOUBLE_QUOTE_STRING_LITERAL = 		'regexp:(@"|")([^"\\\r\n]|\\["\\bfnrtv])*"'
		BOOLEAN_LITERAL = 					'regexp:(true|false|YES|yes|NO|no)'

		HEX_INTEGER_LITERAL =               'regexp:0 [xX] [0-9a-fA-F]+'
		OCTAL_INTEGER_LITERAL =             'regexp:0 [0-7]+'
		OCTAL_INTEGER_LITERAL2 =            'regexp:0 [oO] [0-7]+'
		BINARY_INTEGER_LITERAL =            'regexp:0 [bB] [01]+'
		DECIMAL_LITERAL = 					'regexp:[0-9]*\.[0-9]+([eE] [+-]? [0-9]+)?'
		INTEGER_LITERAL = 					'regexp:[0-9]+'
		//REGULAR_EXPRESSION_LITERAL_TOKEN_LITERAL = 'regexp:^((?:(?:[^?+*{}()[\]\\|]+|\\.|\[(?:\^?\\.|\^[^\\]|[^\\^])(?:[^\]\\]+|\\.)*\]|\((?:\?[:=!]|\?<[=!]|\?>)?(?1)??\)|\(\?(?:R|[+-]?\d+)\))(?:(?:[?+*]|\{\d+(?:,\d*)?\})[?+]?)?|\|)*)$'

		//Comments
		//BLOCK_COMMENT =             		'regexp:/\*([^*]|\*[^/])*\*/'
		SINGLE_LINE_COMMENT =       		'regexp://[^\r\n\u2028\u2029]*'
		ID = 								'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
		PREPROCESSOR_CONTINUE_ON_NEXT_LINE = 	'regexp:\\[ ]*\r?\n'
		PREPROCESSOR_DIRECTIVE =					'regexp:#.+\s+(\\[ ]*\r?\n .+)*[\r\n\u2028\u2029]'
		REGULAR_EXPRESSION_LITERAL_TOKEN =	'regexp:\/ (([^\r\n\u2028\u2029\\\/\[]|\\\\[^\r\n\u2028\u2029]) | \[ ([^\r\n\u2028\u2029\]\\] | \\\\[^\r\n\u2028\u2029])* \] )* \/ [a-zA-Z]*'
	]
	name (".*expr|.+Expr(Prime)?") ='expression'
	extends(".+Block")=block
	consumeTokenMethod("block|.+Block")="consumeTokenFast"
	name("block|.+Block")="statement block"
	name(".+_COMMENT|comment")="comment"
	name("preprocessor.*")="preprocessor statements"
	name("bodyVariableAssignment|variableAssignment.+")="expression"
	name(".+(Literal|LITERAL.+)")="literal value"
	//extends (".*expr|.+Expr")=expr
}

file ::= fileRootElement*

private fileRootElement
	::= !<<eof>> sourceElement
	;

private sourceElement
	::= errorSequence
	|	implementationDeclaration
	| 	protocolDeclaration
	| 	preprocessorStatement
	| 	functionDeclaration
	|	importFile
    | 	importFramework
	|	globalVariableDeclaration eos?
	|	expr eos?
    | 	bodyVariableAssignment eos?
	| 	ifStatement
	|	iterationStatement
	| 	switchStatement
	| 	tryStatement
	| 	debuggerStatement
	| 	typeDef
	| 	global
	| 	classDependencyStatement
	|   comment
	|	includeFile
	|	includeFramework
	| 	emptyStatement
	;

errorSequence
	::= ERROR_SEQUENCE_TOKEN ';'
	{
		pin=1
	}
	;

comment
    ::= blockComment
    |   SINGLE_LINE_COMMENT
    ;

blockComment
	::= BLOCK_COMMENT_START BLOCK_COMMENT_TEXT? BLOCK_COMMENT_END
	{
		pin=1
	}
	;


importFile
	::= '@import' stringLiteral
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFileImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFileImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

importFramework
	::= '@import' frameworkReference
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFrameworkImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFrameworkImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

includeFile
	::= '#include' stringLiteral LINE_TERMINATOR
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFileImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFileImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

includeFramework
	::= '#include' frameworkReference LINE_TERMINATOR
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFrameworkImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFrameworkImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

frameworkReference
	::= IMPORT_FRAMEWORK_LITERAL
	{
		methods=[getFrameworkName getFileName]
	}
	;

private bodyStatement
	::= preprocessorIfStatement
    | 	returnStatement
    | 	ifStatement
    | 	iterationStatement
    | 	withStatement
    | 	switchStatement
    | 	throwStatement
    | 	tryStatement
    | 	debuggerStatement
    |	deleteStatement
    | 	functionDeclaration
    |	/*<<inMode "inLoop">>*/ loopBodyStatement
	|	includeFile
	|	includeFramework
	|	expr eos?
    |	bodyVariableAssignment eos?
	|	block
	| 	comment
	| 	emptyStatement
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
	}
    ;

private preprocessorBodyStatement
	::= <<inMode "inImplementation" >> methodDeclaration
    |	<<inMode "inProtocol" >> protocolScopedBlock
    |	<<inMode "inProtocol" >> protocolHeader
    |  	<<inMode "implementationInstanceVariables">> instanceVariableDeclaration eos?
    |	<<notInMode "inProtocol">> <<notInMode "inImplementation">> sourceElement
    |	elseIfStatement
    |	elseStatement
    |	bodyStatement
   	|	comment
   	| LINE_TERMINATOR
	;

private loopBodyStatement
	::= continueStatement
	|	breakStatement
	;


private statementOrBlock
	::= block
	| 	singleBodyStatement
	;

singleBodyStatement
	::= bodyStatement eos?
	{
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"]
	}
	;

block
	::= '{' blockStatements? '}'
	{
		pin=2;
		//recoverWhile=recover_block;
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasIgnoreStatements"
		]
	}
	;

methodBlock
	::= '{' methodBlockStatements? '}'
	{
		pin=1;
		extends=block
		recoverWhile=recover_methodBlockStatements
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
		]

	}
	;

private methodBlockStatements
	::= blockStatements+
	;

private recover_methodBlockStatements
	::= !(('-'|'+') '('|possibleSourceElementStart|'}'|'#if'|'#endif'|'@end'|'var'|ID)

	;

private blockStatements
	::= bodyStatement+
	{
		recoverWhile=recover_blockStatements
	}
	;

private recover_blockStatements
	::= !('}')
	;


bodyVariableAssignment
	::= variableAssignmentLogical | variableAssignmentSimple
    {
    	//pin=1
    	//recoverWhile=recoverExprSequence
    	implements=[
    		"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
    	]
    }
	;

variableAssignmentLogical
	::= (qualifiedReference|'@deref' '(' variableName ')') assignmentExprPrime
	{
		//pin=2
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJVariableAssignment"
		methods=[getAssignedValue getQualifiedReferenceList]
	}
	;

private variableAssignmentSimple
	::= varModifier? variableDeclarationList
	{
		//pin=2
	}
	;

private variableDeclarationList
	::= (variableDeclaration|qualifiedReference !('('|rightExpr|'--'|'++')) (',' (variableDeclaration|qualifiedReference!('('|rightExpr|'--'|'++')))*
	{
		//pin=1
		//recoverWhile=recover_variableDeclarationsList
	}
	;

globalVariableDeclaration
	::= variableName '=' expr
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJGlobalVariableDeclarationStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
		]
		methods=[getVariableNameString getVariableType getFileName]
	}
	;

variableDeclaration
	::= (qualifiedReference|'@deref' '(' qualifiedReference ')') '=' ((qualifiedReference|'@deref' '(' qualifiedReference ')') '=')* expr
	{
		//pin(".*")='='
		//recoverWhile=recover_variableDeclaration
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJVariableAssignment"
		methods=[assignedValue="/expr"]
	}
	;

private recover_variableDeclaration
	::= !(eos|','|'}')
	;

instanceVariableDeclaration
	::= ('@outlet')? formalVariableType variableName accessor?
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJInstanceVariableDeclarationStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJInstanceVariableDeclarationStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
		]
		methods = [getGetter getSetter getName setName hasContainingClass shouldResolve getContainingSuperClassName getContainingSuperClass getContainingClass getContainingClassName]
		pin=2
		recoverWhile=recover_instanceVariableDeclaration
	}
	;
private recover_instanceVariableDeclaration
	::=  !(eos|recover_instanceVariableList)
	;
private accessor
	::= '@accessors' ('(' accessorPropertyList? ')')?
	;

private accessorPropertyList
	::= accessorProperty (',' accessorProperty)*
	{
		//recoverWhile=recover_accessorPropertyList
	}
	;

private recover_accessorPropertyList
	::= !')'
	;

accessorProperty
	::= accessorPropertyType ('=' selector (':')?)?
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub>"
			]
		methods=[
			accessorKind="/accessorPropertyType"
			accessor="/selector"
			getVarType
			getContainingClass
			isGetter
			getSelectorList
			getSelectorStrings
			getSelectorString
			getContainingClassName
			getContainingSuperClass
			getContainingSuperClassName
			isStatic
			getMethodScope
			getReturnType
			getGetter
			getSetter
			shouldResolve
		]
	}
	;

accessorPropertyType
	::= ID
	;

private emptyStatement
	::= ';'
	;

ifStatement
	::= ifStatementStart elseIfStatement* elseStatement?
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
		]
		methods =[
			conditionalExpression = "/conditionExpression/expr"
		]
	}
	;

private ifStatementStart
	::= 'if' conditionExpression statementOrBlock
	{
		pin=1
		//recoverWhile=recover_if
	}
	;

elseIfStatement
	::= 'else' 'if' conditionExpression statementOrBlock
	{
		pin=2
		extends=ifStatement
		methods = [
			conditionalExpression = "/conditionExpression/expr"
		]
		//recoverWhile=recover_if
	}
	;

private elseStatement
	::= 'else' statementOrBlock
	{
		pin=1
	}
	;

iterationStatement
	::= doWhileStatement
    | 	whileStatement
    |	forStatement
    {
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
    }
    ;


doWhileStatement
	::= 'do' /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/ whileExpression eos?
	{
		pin=1
		//recoverWhile=inLoopRecoverWhile
		extends=whileStatement
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
		]
		methods =[ getConditionalExpression]
	}
	;

whileStatement
	::= whileExpression /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/
	{
		pin=1
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
		]
		methods =[
			conditionalExpression = "/conditionExpression/expr"
		]
		//recoverWhile=inLoopRecoverWhile
	}
	;

private whileExpression
	::= 'while' conditionExpression
	{
		methods =[
			getConditionalExpression = "/conditionExpression/expr"
		]
	}
	;

conditionExpression
	::= '(' expr ')'
	;

private forStatement
	::= 'for' '(' forLoopHeader ')' /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/
	{
		//pin=1
	}
	;

private forLoopHeader
	::= compoundForLoopHeader
	| 	inExpr
	{
		//pin=2
		//recoverWhile=recover_forLoopHeader
	}
	;

private compoundForLoopHeader
	::= variableAssignmentSimple? ';' expressionSequence ';' expressionSequence?
	{
		//pin=2
		//recoverWhile=recover_forLoopHeader
	}
	;

private recover_forLoopHeader
	::= !(')'|'{')
	;




varModifier
	::= 'var'
    | 	'let'
    | 	'const'
	;

private continueStatement
	::= 'continue' eos
	{
		//pin=1
		//recoverWhile=inLoopRecoverWhile
	}
	;

private recover_if
	::= !('else')
	;

breakStatement
	::= 'break' eos
	{
		pin=1
	}
	;

returnStatement
	::= 'return' expr? eos
	{
		pin=1
	}
	;

private withStatement
	::= 'with' '(' expr ')' bodyStatement
	{
		pin=1
	}
	;

switchStatement
	::= 'switch' '(' expr ')' '{' switchBody '}'
	{
		pin=1
		//recoverWhile= recoverBlockWhile
	}
	;

private switchBody
	::= caseClause* (defaultClause caseClause*)?
	{
		//recoverWhile=recover_switchBody
	}
	;

private recover_switchBody
	::= !'}'
	;

caseClause
	::= 'case' expr ':' bracketLessBlock? 'break'?
	{
		pin=1
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
		methods=[getBlockList]
		//recoverWhile=case_recover
	}
	;

bracketLessBlock
	::= bodyStatement+
	{
		implements="cappuccino.ide.intellij.plugin.psi.ObjJBlock"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
	}
	;

private case_recover
	::=	!('}'
	|	'case'
	|	'default'
	);

defaultClause
	::= 'default' ':' bracketLessBlock?
	{
		extends=caseClause
		pin=1
	}
	;

throwStatement
	::= 'throw' /*<<notLineTerminator>>*/ expr eos
	{
		pin=1
	}
	;

tryStatement
	::= 'try' block (catchProduction finallyProduction? | finallyProduction)
	{
		implements = ["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements" "cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"]
		methods = [getBlockList]
		pin=1
	}
	;

catchProduction
	::= 'catch' '(' variableName ')' block
	{
		pin=1
	}
	;

finallyProduction
	::= 'finally' block
	{
		pin=1
	}
	;

debuggerStatement
	::= 'debugger' eos
	;

deleteStatement
	::= 'delete' (qualifiedReference|'('qualifiedReference ')')
	;

functionDeclaration
	::= 'function' (<<notInMode "varDec">> functionName) '(' formalParameterList? ')' block
	{
		pin=1
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<ObjJFunctionDeclarationElementStub<ObjJFunctionDeclarationImpl>>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionDeclarationImpl>>"

			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionDeclarationImpl>"
		methods=[getName setName functionNameNode="/functionName" getFunctionNameAsString getParamNames getReturnType shouldResolve getBlockList]

	}
	;

methodDeclaration
	::=  methodHeader methodBlock
	{
		pin=1
		//recoverWhile=methodDeclaration_recover
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
		//recoverWhile=recover_methodDeclaration
		methods = [
			block="/methodBlock"
		]
	}
	;

private recover_methodDeclaration
	::= recover_classDec
	;


methodHeader
	::= methodScopeMarker '(' (methodHeaderReturnTypeElement) ')' methodHeaderSelectorList
	{
		pin=2
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"com.intellij.psi.PsiNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub>"
		]
		methods = [getSelectorList getSelectorStrings getParamTypes getParamTypesAsStrings getSelectorString getName setName getReturnType getContainingClass getContainingClassName getMethodScope isStatic shouldResolve]

		//recoverWhile=recover_methodHeaderSelectorList
	}
	;

private methodHeaderSelectorList
	::= firstMethodDeclarationSelector methodDeclarationSelector* methodHeaderMultipleVariableTail?
	{
		//recoverWhile=recover_methodHeaderSelectorList
	}
	;

private recover_methodHeaderSelectorList
	::= !('}'|'{'|'@end'|'@required'|'@optional'|('-'|'+') '(')
	;

methodHeaderReturnTypeElement
	::= formalVariableType
	| 	'@action'
	| 	'void'
	;

private methodHeaderMultipleVariableTail
	::= "," "..."
	;
methodScopeMarker
	::= '+'|'-'
	;

firstMethodDeclarationSelector
	::= selector (':' methodDeclarationSelectorVariable)?
	{
		pin=1
		//recoverWhile=methodDeclarationSelector_recover
		extends=methodDeclarationSelector
		methods=[getVarType]
	}
	;

methodDeclarationSelector
	::= selector? ':' methodDeclarationSelectorVariable
	{
		pin=2;
		//recoverWhile=methodDeclarationSelector_recover
		methods = [getVarType getContainingClassName getContainingClass getVarType getFileName]
	}
	;

private methodDeclarationSelector_recover
	::= !(methodDeclarationSelector|'{'|';'|',')
	;

private methodDeclarationSelectorVariable
	::= ('(' (formalVariableType|'void') ')')? variableName
	;

implementationDeclaration
	::= implementationHeader <<enterMode "inImplementation" >> implementationInstanceVariables? implementationElements? <<exitMode "inImplementation" >>'@end'
	{
		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJClassDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasIgnoreStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub"
		methods = [
			className = "/className[0]"
			superClass="/className[1]"
			isCategory
			getClassNameString
			getSuperClassName
			hasMethod
			getPresentation
			shouldResolve
			getUnimplementedProtocolMethods
			getAllUnimplementedProtocolMethods
			getMethodHeaderList
			getInheritedProtocols
		]
	}
	;

private implementationElements
	::= implementationElement+
	{
		recoverWhile=recover_implementationElements
	}
	;

private recover_implementationElements
	::= !('@end'|possibleSourceElementStart)
	;

private implementationHeader
	::= '@implementation' className (implementationInheritanceDeclaration)?
	{
		pin=1
		//recoverWhile=recover_implementationHeader
	}
	;

private implementationInheritanceDeclaration
	::= (categoryName |':' className)? (inheritedProtocolList)?
	;

categoryName
	::= '(' className ')'
	{
		methods = [
			categoryName="/className"
		]
	}
	;

inheritedProtocolList
	::= '<' protocolClassNamesList '>'
	{
		pin=2
		//recoverWhile = recoverInheritedAt
	}
	;

private protocolClassNamesList
	::= className (',' className)*
	{
		//recoverWhile=recover_protocolClassNamesList
	}
	;

private recover_protocolClassNamesList
	::= !('>'|'{')
	;

private recover_implementationHeader
	::=	!('{'
	|	'-'
	|	'+'
	|	'function'
	|	'var'
	|	preprocessorStatement
	)
	;

private implementationInstanceVariables
	::= '{' <<enterMode "implementationInstanceVariables">> instanceVariableList? <<exitMode "implementationInstanceVariables">> '}'
	{
		pin=1;
	}
	;

private recover_implementationInstanceVariables
	::= !(('-'|'+') '('|possibleSourceElementStart)
	;

instanceVariableList
	::= ( comment | preprocessorInstanceVariableListIfStatement | instanceVariableDeclaration eos? )+
	{
		recoverWhile=recover_instanceVariableList
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
	}
	;
private recover_instanceVariableList
	::= !'}'
	;

private preprocessorStatement
	::= preprocessorIfStatement
	|	preprocessorDefineFunction
	|	preprocessorUndef
	|	preprocessorPragma
	| 	'#warning' stringLiteral LINE_TERMINATOR
	| 	'#error' stringLiteral LINE_TERMINATOR
	|	PREPROCESSOR_DIRECTIVE
	;

preprocessorDefineFunction
	::= '#define' (functionName '(' formalParameterList? ')' | variableName) <<enterMode "preprocessor">> preprocessorDefineBody <<exitMode "preprocessor">>LINE_TERMINATOR
	{
		pin=1;
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>"
		methods=[getName setName functionNameNode="/functionName" getFunctionNameAsString getParamNames getReturnType getBlock shouldResolve]
	}
	;

preprocessorDefineBody
	::= preprocessorBodyStatementList|block|expr ';'?
	{
		//recoverWhile=recover_preprocessorDefineBody
	}
	;
preprocessorBodyStatementList
	::= bodyStatement+
	;

private recover_preprocessorDefineBody
	::= !(LINE_TERMINATOR)
	;

preprocessorUndef
	::= '#undef' variableName LINE_TERMINATOR
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorPragma
	::= preprocessorPragmaMark
	|	'#pragma' (ID|doubleQuoteStringLiteral)* LINE_TERMINATOR {
		pin(".*")=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorPragmaMark
	::= '#pragma' 'mark'? PRAGMA_MARKER
	{
		pin=1;
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorDefined
	::= '#defined' ID
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

private preprocessorInstanceVariableListIfStatement
	::= <<inMode "implementationInstanceVariables">> '#if'  preprocessorIfCondition LINE_TERMINATOR  preprocessorInstanceVariableList ('#elif' (preprocessorIfExpr ('||'|'&&' preprocessorIfExpr)*) LINE_TERMINATOR preprocessorInstanceVariableList )* ('#else' LINE_TERMINATOR preprocessorInstanceVariableList)? '#endif' LINE_TERMINATOR
	{
		pin=2
		extends=preprocessorIfStatement
		//recoverWhile = recoverPragmaWhile
	}
	;

preprocessorIfCondition
	::= preprocessorIfExpr ('||'|'&&' preprocessorIfExpr)*
	{
		//recoverWhile=recover_preprocessorIfCondition
	}
	;

private recover_preprocessorIfCondition
	::= !('#if'|'#elif'|'#else'|LINE_TERMINATOR|"#endif")
	;

private preprocessorInstanceVariableList
	::= (comment|instanceVariableDeclaration eos?|LINE_TERMINATOR)+
	{
		recoverWhile=recover_preprocessorIfCondition
	}
	;

private preprocessorIfExpr
	::= expr
	|	preprocessorDefined
	;

preprocessorIfStatement
	::=	'#if' preprocessorIfCondition LINE_TERMINATOR preprocessorBodyStatements? ('#elif' preprocessorIfCondition LINE_TERMINATOR preprocessorBodyStatements?)* ('#else' LINE_TERMINATOR preprocessorBodyStatements?)? '#endif' LINE_TERMINATOR
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement" "cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements" "cappuccino.ide.intellij.plugin.psi.ObjJBlock"]
		methods=[getOpenBrace];
	}
	;

private preprocessorBodyStatements
	::= preprocessorBodyStatement+
	{
		recoverWhile=recover_preprocessorBodyStatements
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons" ]
	}
	;

private recover_preprocessorBodyStatements
	::= !('#else' | '#elif'|'#endif')
	;




protocolDeclaration
	::= protocolHeader protocolBody '@end'
	{
		pin=1
		//recoverWhile=protocolRecoverDecWhile

		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJClassDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJProtocolDeclarationMixin"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub"
		methods=[getMethodHeaderList hasMethod getPresentation shouldResolve getInheritedProtocols]
	}
	;

private protocolBody
	::= <<enterMode "inProtocol" >> (preprocessorIfStatement|protocolSection)* <<exitMode "inProtocol" >>
	{
		//recoverWhile=recover_classDec
	}
	;

private recover_classDec
	::= !(possibleSourceElementStart)
	;

private possibleSourceElementStart
	::= '@end'|'@implementation'|'@protocol'|'@import'|'@class'| '@global'|'#define'|'#include'|'#pragma'|'#error'|'#warning'
	;

private protocolHeader
	::= '@protocol' className  inheritedProtocolList?
	{
		pin=1
		//recoverWhile=recover_protocolHeader
	}
	;

private recover_protocolHeader
	::= !('@optional' | '@required' | '-' | '+')
	;

private protocolSection
	::= protocolScopedBlock
	|	protocolStatementList
	;

protocolScopedBlock
	::= ('@optional'|'@required') protocolStatementList?
	{
		//recoverWhile=recover_classDec
	}
	;

private protocolStatementList
	::= (protocolStatement eos)+
	{
		//recoverWhile=recover_protocolSection
	}
	;

private recover_protocolSection
	::= !('@optional'|'@required'|'@end')
	;


private protocolStatement
	::= methodHeader
	| instanceVariableDeclaration
	;

private implementationElement
	::= preprocessorIfStatement
    | 	preprocessorStatement
    |	variableAssignmentSimple eos
	| 	methodDeclaration
    | 	functionDeclaration
    |	comment
    {
    	//recoverWhile=implementationElement_recover
    }
	;

typeDef
	::=	'@typedef' ID
	;

global
	::= '@global' variableName expr?
	;

private formalParameterList
	::= formalParameterArg (',' formalParameterArg)* (',' lastFormalParameterArg)?
    | lastFormalParameterArg
    {
    	recoverWhile=recover_formalParameterList
    }
	;

private recover_formalParameterList
	::= !')'
	;

formalParameterArg
	::= variableName ('=' expr)?
	{
		pin(".*")=1
		recoverWhile=recover_formalParameterArg
	}
	;

private recover_formalParameterArg
	::= !(','|')')
	;

lastFormalParameterArg
	::= '...' variableName
	{
		//recoverWhile=recover_formalParameterList
	}
	;

arrayLiteral
	 ::= ('@['|'[') arrayLiteralExpressionList? ']' {
	 	pin=3
	 	//recoverWhile=recoverExprSequence
	 }
	;

private arrayLiteralExpressionList
	::= (',')* (expr (',' expr?)*)?
	{
		recoverWhile=recover_arrayLiteralExpressionList
	}
	;

private recover_arrayLiteralExpressionList
	::= !(']'|'}'|';')
	;

objectLiteral
	::= ('@{'|'{') objectLiteralPropertiesList '}'
	|	('@{'|'{') '}'
	{
		pin(".*")=2
	 	//recoverWhile=recoverExprSequence
	}
	;

private objectLiteralPropertiesList
	::= propertyAssignment (',' propertyAssignment?)*
	{
		recoverWhile=recover_objectLiteralPropertiesList
	}
	;

private recover_objectLiteralPropertiesList
	::= !'}'
	;

propertyAssignment
	::= propertyName (':') expr
	{
		pin=2
		//recoverWhile=recover_propertyAssignment
	}
	;

private recover_propertyAssignment
	::= !('}'|',')
	;

private propertyName
	::= ID
	|	stringLiteral
    | 	integer
	;

methodCall
	::= '[' callTarget !(','|']'|mathOp|assignmentOperator|'='|rightExpr) methodCallSelectorList ']'
	{
		pin=3
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasMethodSelector"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodCallStub>"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodCallStub"
		//recoverWhile = recover_methodCall
		methods = [getSelectorList getSelectorStrings getContainingClass getContainingClassName getSelectorString getCallTargetText getPossibleCallTargetTypes singleSelector="/selector" shouldResolve]
	}
	;

private recover_methodCall
	::= !(eos|keyword)
	;

private methodCallSelectorList
	::= qualifiedMethodCallSelector+
	|	selector ':'?
	{
		pin(".*")=1
		recoverWhile=recover_methodCallSelectorList
	}
	;
private recover_methodCallSelectorList
	::= !(']'|eos|keyword)
	;

qualifiedMethodCallSelector
	::= selector? ':' expr (',' expr)*
	{
		pin=2
		//recoverWhile=recover_qualifiedMethodCallSelector
	}
	;
private recover_qualifiedMethodCallSelector
	::= recover_methodCallSelectorList | !selector
	;

selector
	::= 'with'
	| 	'delete'
	| 	'function'
	| 	'new'
	| 	ID
	|	'null'
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"com.intellij.navigation.NavigationItem"
		]
		methods=[setName getName getSelectorString getRangeInElement getReferences getContainingClass getContainingClassName getPresentation shouldResolve]
		//recoverWhile=recover_selector
	}
	;

private recover_selector
	::= !(':'|']')
	;

classDependencyStatement
	::= '@class' className
	;

private expressionSequence
	::= expr (',' expr?)*
	{
		pin(".*")=2
		//recoverWhile=recover_expressionSequence
	}
	;

private expressionSequenceElement
	::= expr
	{
		//recoverWhile=recover_expressionSequenceElement
	}
	;
private recover_expressionSequenceElement
	::= !(']'|'}'|')'|',')
	;

private recover_expressionSequence
	::= !(']'|'}'|')')
	;


expr
	::= comment+ expr comment*
	|	('!'|'~'|'-'|'+') expr
 	|	leftExpr rightExpr*
 	|	leftExpr
    {
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
		]
		methods = [getBlock shouldResolve]
		//recoverWhile=recover_statement
	}
	;

leftExpr
	::= incrementExpr
	|	'@ref' '(' variableName ')'
	|	variableDeclaration
	|	functionCall
    |	methodCall
    | 	'new' expr ('(' expressionSequence? ')')?
	|	variableAssignmentLogical
    |	qualifiedReference
    |	objectLiterals
    |	primary
	|	enclosedExpr
	|	typeOfExprPrime
    |	regularExpressionLiteral
	;

enclosedExpr
	::= arrayIndexSelector
	| 	parenEnclosedExpr
	;

private parenEnclosedExpr
	::= '(' expr ')'
	;
private incrementExpr
	::= ('--'|'++') qualifiedReference
   	| 	qualifiedReference ('++'|'--')
	;

functionCall
	::= ((qualifiedReference '.')? functionName|methodCall) (arrayIndexSelector)? '(' expressionSequence? ')'
	{
		pin=3
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedNamePart"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionCallElement"
			//"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		methods=[getQualifiedNameText]

	}
	;

rightExpr
	::= qualifiedReferencePrimary+
	| 	boolAssignExprPrime
	| 	instanceOfExprPrime
	| 	joinExprPrime
	|	mathExprPrime
	|	booleanExprPrime
	|	assignmentExprPrime
	| 	'in' (qualifiedReference|objectLiteral)
	;


instanceOfExprPrime
	::= 'instanceof' qualifiedReference
	;

typeOfExprPrime
	::= 'typeof' ('('expr')'|expr)
	;

inExpr
	::= varModifier? variableName 'in' expr
	;

joinExprPrime
	::= ('||'|'&&') expr
	;

booleanExprPrime
	::= booleanOp expr
	;

boolAssignExprPrime
	::= '?' expr ':' expr
	{
		methods = [ifTrue="/expr[0]" ifFalse="/expr[1]"]
	}
	;

private booleanOp
	::= '<'|'>'|'<='|'>='|'=='|'==='|'!='|'!=='
	;

assignmentExprPrime
	::= assignmentOperator expr
	{
		//pin=1
		//recoverWhile=recover_statement
	};

mathExprPrime
	::= mathOp expr
	;

private mathOp
	::= '+'|'-'|'*'|'/'|'%'|'<<'|'>>'|'<<<'|'>>>'|'^'|'~'|'&'|'|'
	;

private assignmentOperator
	::= '*='
    | 	'/='
    | 	'%='
    | 	'+='
    | 	'-='
    | 	'<<='
    | 	'<<<='
    | 	'>>='
    | 	'>>>='
    | 	'&='
    | 	'^='
    | 	'|='
	;

primary
	::= BOOLEAN_LITERAL
	| 	stringLiteral
	| 	numericLiteral
	| 	nullLiterals
	;

nullLiterals
	::= 'null'
	| 	'nil'
	| 	'undefined'
	;

formalVariableType
	::= varTypeId
	| VAR_TYPE_CHAR
	| VAR_TYPE_BYTE
	| VAR_TYPE_SHORT
	| VAR_TYPE_INT
	| VAR_TYPE_LONG_LONG
	| VAR_TYPE_LONG
	| VAR_TYPE_FLOAT
	| VAR_TYPE_DOUBLE
	| VAR_TYPE_IBOUTLET
	| VAR_TYPE_IBACTION
	| VAR_TYPE_BOOL
	| VAR_TYPE_SEL
	| VAR_TYPE_UNSIGNED
	| VAR_TYPE_SIGNED
	| className
	;

varTypeId
	::= 'id' ('<' varTypeIdClassName '>')?
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVarTypeIdStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVarTypeIdStub"
		methods=[getIdType shouldResolve]
	}
	;
private varTypeIdClassName
	::= className
	{
		pin=1
		recoverWhile=recover_varTypeIdClassName
	}
	;
private recover_varTypeIdClassName
	::= !('>'|')'|';'|'@accessors')
	;

private objectLiterals
	::=	arrayLiteral
    | 	objectLiteral
    | 	functionLiteral
    | 	selectorLiteral
    /*| 	REGULAR_EXPRESSION_LITERAL_TOKEN_LITERAL*/
	;

functionLiteral
	::= 'function' '(' formalParameterList? ')' block
	{
		pin=1
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionLiteralImpl>"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<ObjJFunctionDeclarationElementStub<ObjJFunctionLiteralImpl>>"
		]
		methods = [getFunctionNameNode getFunctionNameAsString getFunctionNamesAsString getReturnType getParamNameElements getParamNames getFunctionNameNode shouldResolve getBlockList]
	}
	;

selectorLiteral
	::= '@selector' '(' selectorLiteralSelectorList ')'
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub>"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub"
		methods=[getReference getSelectorStrings getContainingClass getContainingClassName getSelectorString isStatic getMethodScope getReturnType shouldResolve]
	}
	;

private selectorLiteralSelectorList
	::= (selector ':')* selector?
	{
		//recoverWhile=recover_selectorLiteralSelectorList
	}
	;

private recover_selectorLiteralSelectorList
	::= !(')'|eos|keyword)
	;

private numericLiteral
	::= DECIMAL_LITERAL
    | 	integer
	;

integer
	::=	HEX_INTEGER_LITERAL
  	| 	OCTAL_INTEGER_LITERAL
   	|	OCTAL_INTEGER_LITERAL2
   	| 	BINARY_INTEGER_LITERAL
   	| 	INTEGER_LITERAL
   	;

regularExpressionLiteral
	::= REGULAR_EXPRESSION_LITERAL_TOKEN
	;

callTarget
	::= functionCall
	|	qualifiedReference
    | 	expr
	;

qualifiedReference
	::= (variableName|methodCall) qualifiedReferencePrimary*
	{
		methods = [
			primaryVar ="/variableName[0]"
			getLastVar
			getPartsAsString
			getPartsAsStringArray
		]
	}
	;

private qualifiedReferencePrimary
	::= '.' (functionCall|variableName)
	|	arrayIndexSelector
	;

arrayIndexSelector
	::= '[' expr ']'
	;

stringLiteral
	::= doubleQuoteStringLiteral | singleQuoteStringLiteral
	{
		methods=[getStringValue]
	}
	;


private keyword
	::= BREAK
    | 	DO
    | 	INSTANCE_OF
    | 	TYPE_OF
    | 	CASE
    | 	ELSE
    | 	NEW
    | 	VAR
    | 	CATCH
    | 	FINALLY
    | 	RETURN
    | 	VOID
    | 	CONTINUE
    | 	FOR
    | 	SWITCH
    | 	WHILE
    | 	DEBUGGER
    | 	FUNCTION
    | 	THIS
    | 	WITH
    | 	DEFAULT
    | 	IF
    | 	THROW
    | 	DELETE
    | 	IN
    | 	TRY
    | 	CONST
    | 	LET
	;

className
	::= ID
	{
		methods = [getReference getReferences]
	}
	;

variableName
	::= ID
	|	'this'
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVariableNameStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedNamePart"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVariableNameStub>"
		]
		methods = [toString getReference getRangeInElement getRangeInElement getName setName hasText getContainingClass getContainingClassName getQualifiedNameText shouldResolve]
	}
	;

functionName
	::= ID
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		methods = [getName setName getReference shouldResolve]
	}
	;

doubleQuoteStringLiteral
	::= ("\""|"@\"") QUO_TEXT? "\""
	{
		pin=2
	}
	;

singleQuoteStringLiteral
	::= "'" QUO_TEXT? "'"
	{
		pin=2
	}
	;

private recover_blockComment
	::= '*/'
	;

private eos
	::= <<lineTerminatorAhead>> ';'?
	|	<<notLineTerminator>> ';'
	|	'}'
    ;

