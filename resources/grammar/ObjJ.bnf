{
	parserClass="cappuccino.ide.intellij.plugin.parser.ObjectiveJParser"
	parserUtilClass="cappuccino.ide.intellij.plugin.parser.ObjectiveJParserUtil"
	implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
	extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJCompositeElementImpl"
	elementTypeHolderClass="cappuccino.ide.intellij.plugin.psi.types.ObjJTypes"
	elementTypePrefix="ObjJ_"
	elementTypeClass="cappuccino.ide.intellij.plugin.psi.types.ObjJCompositeElementType"
	tokenTypeClass="cappuccino.ide.intellij.plugin.psi.types.ObjJTokenType"
	psiClassPrefix="ObjJ"
	psiImplClassSuffix="Impl"
	psiPackage="cappuccino.ide.intellij.plugin.psi"
	psiImplPackage="cappuccino.ide.intellij.plugin.psi.impl"
	generateTokenAccessors=true
	elementTypeFactory("implementationDeclaration|methodHeader|protocolDeclaration|instanceVariableDeclaration|accessorProperty|methodCall|selectorLiteral|functionDeclaration|functionLiteral|preprocessorDefineFunction|globalVariableDeclaration|importFile|importFramework|includeFile|includeFramework|varTypeId|variableName|typeDef|className")="cappuccino.ide.intellij.plugin.psi.types.ObjJElementTypeFactory.factory"
	psiImplUtilClass="cappuccino.ide.intellij.plugin.psi.utils.ObjJPsiImplUtil"
	//Tokens
	tokens = [
		//Line Terminator
		LINE_TERMINATOR =                 	'regexp:[\r\n\u2028\u2029]'
		space = 							'regexp:\s+'
		//Symbols
		AT_OPENBRACKET = 					'@['
		OPEN_BRACKET =                    	'['
		CLOSE_BRACKET =                   	']'
		OPEN_PAREN =                      	'('
		CLOSE_PAREN =                     	')'
		OPEN_BRACE =                      	'{'
		CLOSE_BRACE =                     	'}'
		SEMI_COLON =                      	';'
		COMMA =                          	','
		ASSIGN =                         	'='
		QUESTION_MARK =                   	'?'
		COLON =                         	':'
		ELLIPSIS =                       	'...'
		DOT =                            	'.'
		PLUS_PLUS =                      	'++'
		MINUS_MINUS =                     	'--'
		PLUS =                           	'+'
		MINUS =                          	'-'
		BIT_NOT =                         	'~'
		NOT =                            	'!'
		MULTIPLY =                       	'*'
		DIVIDE =                         	'/'
		MODULUS =                        	'%'
		RIGHT_SHIFT_ARITHMATIC =           	'>>'
		LEFT_SHIFT_ARITHMATIC =            	'<<'
		RIGHT_SHIFT_LOGICAL =              	'>>>'
		LEFT_SHIFT_LOGICAL =             	'<<<'
		LESS_THAN =                       	'<'
		GREATER_THAN =                    	'>'
		LESS_THAN_EQUALS =                 	'<='
		GREATER_THAN_EQUALS =              	'>='
		EQUALS =                        	'=='
		NOT_EQUALS =                      	'!='
		IDENTITY_EQUALS =                 	'==='
		IDENTITY_NOT_EQUALS =              	'!=='
		BIT_AND =                         	'&'
		BIT_XOR =                         	'^'
		BIT_OR =                          	'|'
		AND =                            	'&&'
		OR =                             	'||'
		MULTIPLY_ASSIGN =                 	'*='
		DIVIDE_ASSIGN =                   	'/='
		MODULUS_ASSIGN =                  	'%='
		PLUS_ASSIGN =                     	'+='
		MINUS_ASSIGN =                    	'-='
		LEFT_SHIFT_ARITHMATIC_ASSIGN =      '<<='
		RIGHT_SHIFT_ARITHMATIC_ASSIGN =     '>>='
		LEFT_SHIFT_LOGICAL_ASSIGN =        '<<<='
		RIGHT_SHIFT_LOGICAL_ASSIGN =        '>>>='
		BIT_AND_ASSIGN =                   	'&='
		BIT_XOR_ASSIGN =                   	'^='
		BIT_OR_ASSIGN =                    	'|='
		ARROW =                          	'=>'
		DOUBLE_QUO =						'"'
		AT_DOUBLE_QUOTE	=					"@\""
		SINGLE_QUO = 						"'"
		BLOCK_COMMENT_START =				"/*"
		BLOCK_COMMENT_END =				 	"*/"
		BLOCK_COMMENT_LEADING_ASTERISK =     "*"
		BLOCK_COMMENT_LINE =				'regexp:\*[^\n]*?'

		// At Statements
		AT_FRAGMENT =						'@fragment'
		AT_IMPORT  = 						'@import'
		AT_ACCESSORS  = 					'@accessors'
		AT_END  = 							'@end'
		AT_ACTION  = 						'@action'
		AT_SELECTOR  = 						'@selector'
		AT_CLASS  = 						'@class'
		AT_GLOBAL  = 						'@global'
		AT_REF  = 							'@ref'
		AT_DEREF  = 						'@deref'
		AT_PROTOCOL  = 						'@protocol'
		AT_OPTIONAL  = 						'@optional'
		AT_REQUIRED = 						'@required'
		AT_INTERFACE  = 					'@interface'
		AT_TYPE_DEF  = 						'@typedef'
		AT_IMPLEMENTATION  = 				'@implementation'
		AT_OUTLET  = 						'@outlet'
		AT_OPEN_BRACE =						'@{'

		/// Null Literals
		NULL_LITERAL =                    	'null'
		NIL =								'nil'
		UNDEFINED=							'undefined'

		//Preprocessor
		PP_FRAGMENT	=						'#fragment'
		PP_DEFINE = 						'#define'
		PP_UNDEF = 							'#undef'
		PP_IF_DEF = 						'#ifdef'
		PP_IF_NDEF = 						'#ifndef'
		PP_IF = 							'#if'
		PP_ELSE = 							'#else'
		PP_END_IF = 						'#endif'
		PP_ELSE_IF = 						'#elif'
		PP_PRAGMA = 						'#pragma'
		PP_DEFINED = 						'#defined'
		PP_ERROR = 							'#error'
		PP_WARNING = 						'#warning'
		PP_INCLUDE = 						'#include'

		//'var' Types
		//VAR_TYPE_ID = 					'id'
		VAR_TYPE_BYTE = 					'regexp:((unsigned|signed)[ ]+)?byte'
		VAR_TYPE_CHAR = 					'regexp:((unsigned|signed)[ ]+)?char'
		VAR_TYPE_SHORT = 					'regexp:((unsigned|signed)[ ]+)?short'
		VAR_TYPE_INT = 						'regexp:((unsigned|signed)[ ]+)?int'
		VAR_TYPE_LONG_LONG = 				'regexp:((unsigned|signed)[ ]+)?long[ ]+long'
		VAR_TYPE_LONG =						'regexp:((unsigned|signed)[ ]+)?long'
		VAR_TYPE_SIGNED =					'signed'
		VAR_TYPE_UNSIGNED = 				'unsigned'
		VAR_TYPE_IBACTION = 				'IBAction'
		VAR_TYPE_IBOUTLET = 				'IBOutlet'
		VAR_TYPE_SEL = 						'SEL'
		VAR_TYPE_FLOAT= 					'float'
		VAR_TYPE_DOUBLE= 					'double'
		VAR_TYPE_BOOL = 					'BOOL'
		IMPORT_FRAMEWORK_LITERAL = 			'regexp:<.*/.*>'
		//Keywords
		BREAK =                          	'break'
		DO =                             	'do'
		INSTANCE_OF =                     	'instanceof'
		TYPE_OF =                         	'typeof'
		CASE =                           	'case'
		ELSE =                           	'else'
		NEW =                            	'new'
		VAR =                            	'var'
		CATCH =                          	'catch'
		FINALLY =                        	'finally'
		RETURN =                        	'return'
		VOID =                           	'void'
		CONTINUE =                       	'continue'
		FOR =                            	'for'
		SWITCH =                         	'switch'
		WHILE =                          	'while'
		DEBUGGER =                       	'debugger'
		FUNCTION =                       	'function'
		THIS =                           	'this'
		WITH =                           	'with'
		DEFAULT =                        	'default'
		IF =                             	'if'
		THROW =                          	'throw'
		DELETE =                         	'delete'
		IN =                             	'in'
		TRY =                            	'try'
		//SUPER =                          	'super'
		LET = 								'let'
		CONST = 							'const'
		MARK = 								'mark'
		ERROR_SEQUENCE_TOKEN				'?*_ERR_SEMICOLON_*?'

		//Literals
		//SINGLE_QUOTE_STRING_LITERAL = 		"regexp:'([^'\\\r\n]|\\['\\bfnrtv])*'"
		//DOUBLE_QUOTE_STRING_LITERAL = 		'regexp:(@"|")([^"\\\r\n]|\\["\\bfnrtv])*"'
		BOOLEAN_LITERAL = 					'regexp:(true|false|YES|yes|NO|no)'

		HEX_INTEGER_LITERAL =               'regexp:0 [xX] [0-9a-fA-F]+'
		OCTAL_INTEGER_LITERAL =             'regexp:0 [0-7]+'
		OCTAL_INTEGER_LITERAL2 =            'regexp:0 [oO] [0-7]+'
		BINARY_INTEGER_LITERAL =            'regexp:0 [bB] [01]+'
		DECIMAL_LITERAL = 					'regexp:[0-9]*\.[0-9]+([eE] [+-]? [0-9]+)?'
		INTEGER_LITERAL = 					'regexp:[0-9]+'
		//REGULAR_EXPRESSION_LITERAL_TOKEN_LITERAL = 'regexp:^((?:(?:[^?+*{}()[\]\\|]+|\\.|\[(?:\^?\\.|\^[^\\]|[^\\^])(?:[^\]\\]+|\\.)*\]|\((?:\?[:=!]|\?<[=!]|\?>)?(?1)??\)|\(\?(?:R|[+-]?\d+)\))(?:(?:[?+*]|\{\d+(?:,\d*)?\})[?+]?)?|\|)*)$'

		//Comments
		//BLOCK_COMMENT =             		'regexp:/\*([^*]|\*[^/])*\*/'
		SINGLE_LINE_COMMENT =       		'regexp://[^\r\n\u2028\u2029]*'
		ID = 								'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
		PREPROCESSOR_CONTINUE_ON_NEXT_LINE = 	'regexp:\\[ ]*\r?\n'
		PREPROCESSOR_DIRECTIVE =					'regexp:#.+\s+(\\[ ]*\r?\n .+)*[\r\n\u2028\u2029]'
		REGULAR_EXPRESSION_LITERAL_TOKEN =	'regexp:/(([^\r\n\u2028\u2029\\/\[]|\\\\[^\r\n\u2028\u2029]) | \[ ([^\r\n\u2028\u2029\]\\] | \\\\[^\r\n\u2028\u2029])* \] )* / [a-zA-Z]*'
	]
	name (".*expr|.+Expr(Prime)?") ='expression'
	consumeTokenMethod("block|.+Block")="consumeTokenFast"
	name("block|.+Block")="statement block"
	name(".+_COMMENT|comment")="comment"
	name("preprocessor.*")="preprocessor statements"
	name("bodyVariableAssignment|variableAssignment.+")="expression"
	name(".+(Literal|LITERAL.+)")="literal value"
	//extends (".*expr|.+Expr")=expr
}

file ::= fileRootElement*

private fileRootElement
	::= !<<eof>> sourceElement
	;

private sourceElement
	::= errorSequence
	|	implementationDeclaration
	| 	protocolDeclaration
	| 	preprocessorStatement
	| 	functionDeclaration
	|	importBlock
	|	globalVariableDeclaration eos?
	|	expr eos?
    | 	bodyVariableAssignment eos?
	| 	ifStatement
	|	iterationStatement
	| 	switchStatement
	| 	tryStatement
	| 	debuggerStatement
	| 	typeDef
	| 	global
	| 	classDependencyStatement
	|   comment
	|	includeBlock
	| 	emptyStatement
	|	fragment eos?
	;

errorSequence
	::= ERROR_SEQUENCE_TOKEN ';'
	{
		pin=1
	}
	;

comment
    ::= blockComment
    |   SINGLE_LINE_COMMENT
    ;

blockComment
	::= BLOCK_COMMENT_START blockCommentBody? BLOCK_COMMENT_END
	{
		pin=1
	}
	;

blockCommentBody
	::= BLOCK_COMMENT_LEADING_ASTERISK BLOCK_COMMENT_LINE
	| BLOCK_COMMENT_LEADING_ASTERISK
	| BLOCK_COMMENT_LINE
	;

importBlock
	::= importStatementElement+
	;

importStatementElement
	::= importFile
	|	importFramework
	;

importFile
	::= '@import' stringLiteral
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFileImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFileImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

importFramework
	::= '@import' frameworkReference
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFrameworkImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJImportFrameworkImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;


includeBlock
	::= includeStatementElement+
	;

includeStatementElement
	::= includeFile
	|	includeFramework
	;

includeFile
	::= PP_INCLUDE stringLiteral LINE_TERMINATOR
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFileImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFileImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

includeFramework
	::= PP_INCLUDE frameworkReference LINE_TERMINATOR
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJImportStatement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFrameworkImpl>>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImportStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJIncludeFrameworkImpl>"
		methods=[getFrameworkName getFileName getImportAsUnifiedString]
	}
	;

frameworkReference
	::= IMPORT_FRAMEWORK_LITERAL
	{
		methods=[getFrameworkName getFileName]
	}
	;

private bodyStatement
	::= preprocessorIfStatement
    | 	returnStatement
    | 	ifStatement
    | 	iterationStatement
    | 	withStatement
    | 	switchStatement
    | 	throwStatement
    | 	tryStatement
    | 	debuggerStatement
    |	deleteStatement
    | 	functionDeclaration
    |	/*<<inMode "inLoop">>*/ loopBodyStatement
	|	includeFile
	|	includeFramework
	|	expr eos?
    |	bodyVariableAssignment eos?
	|	blockElement
	| 	comment
	| 	emptyStatement
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
	}
    ;

private preprocessorBodyStatement
	::= <<inMode "inImplementation" >> methodDeclaration
    |	<<inMode "inProtocol" >> protocolScopedMethodBlock
    |	<<inMode "inProtocol" >> protocolHeader
    |  	<<inMode "implementationInstanceVariables">> instanceVariableDeclaration
    |	<<notInMode "inProtocol">> <<notInMode "inImplementation">> sourceElement
    |	elseIfStatement
    |	elseStatement
    |	bodyStatement
   	|	comment
   	| LINE_TERMINATOR
	;

private loopBodyStatement
	::= continueStatement
	|	breakStatement
	;


statementOrBlock
	::= blockElement
	| 	singleBodyStatement
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJBlockMixin"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
		methods=[block="this" getOpenBrace]
	}
	;

private singleBodyStatement
	::= bodyStatement eos?
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
		]
	}
	;

blockElement
	::= '{' blockStatements? '}'
	{
		pin=2;
		//recoverWhile=recover_block;
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasIgnoreStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBraces"
		]
		methods=[
			getBlockList
			getIterationStatementList
			getCloseBrace
		]
	}
	;

methodBlock
	::= '{' methodBlockStatements? '}'
	{
		pin=1;
		recoverWhile=recover_methodBlockStatements
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJBlockMixin"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBraces"
		]
		methods=[
			getIterationStatements
			getCloseBrace
		]
	}
	;

private methodBlockStatements
	::= blockStatements+
	;

private recover_methodBlockStatements
	::= !(('-'|'+') '('|possibleSourceElementStart|'}'|PP_IF|PP_END_IF|AT_END|VAR|ID)

	;

private blockStatements
	::= bodyStatement+
	{
		recoverWhile=recover_blockStatements
	}
	;

private recover_blockStatements
	::= !('}')
	;


bodyVariableAssignment
	::= variableAssignmentLogical | variableAssignmentSimple
    {
    	implements=[
    		"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
    	]
    }
	;

variableAssignmentLogical
	::= (qualifiedReference|derefExpression) assignmentExprPrime
	{
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJVariableAssignment"
		methods=[getAssignedValue getQualifiedReferenceList]
	}
	;

private variableAssignmentSimple
	::= varModifier variableDeclarationList
	;

variableDeclarationList
	::=  variableDeclarationListVariableDeclaration (',' variableDeclarationListVariableDeclaration)*
	;

private variableDeclarationListVariableDeclaration
	::= variableDeclaration
	|	variableName !('('|rightExpr|'--'|'++')
	;

globalVariableDeclaration
	::= variableName '=' expr
	{
		pin=2
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJGlobalVariableDeclarationStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
		]
		methods=[getVariableNameString getVariableType getFileName]
	}
	;

variableDeclaration
	::= (qualifiedReference|derefExpression) '=' ((qualifiedReference|derefExpression) '=')* expr
	{
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJVariableAssignment"
		methods=[assignedValue="/expr"]
	}
	;

instanceVariableDeclaration
	::= ('@outlet')? formalVariableType variableName accessor? eos
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJInstanceVariableDeclarationStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJInstanceVariableDeclarationStub>"
		]
		methods = [getGetter getSetter getName setName hasContainingClass shouldResolve getContainingSuperClassName getContainingSuperClass getContainingClass getContainingClassName createTreeStructureElement getAccessorPropertyList]
		pin=2
		recoverWhile=recover_instanceVariableDeclaration
	}
	;

private recover_instanceVariableDeclaration
	::=  !(eos|recover_instanceVariableList)
	;

accessor
	::= '@accessors' ('(' accessorPropertyList? ')')?
	;

private accessorPropertyList
	::= accessorProperty (',' accessorProperty)*
	;

accessorProperty
	::= accessorPropertyType ('=' selector (':')?)?
	{
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJAccessorPropertyStub>"
			]
		methods=[
			accessorKind="/accessorPropertyType"
			accessor="/selector"
			getVarType
			getContainingClass
			isGetter
			getSelectorList
			getSelectorStrings
			getSelectorString
			getContainingClassName
			getContainingSuperClass
			getContainingSuperClassName
			isStatic
			getMethodScope
			getReturnType
			getGetter
			getSetter
			shouldResolve
		]
	}
	;

accessorPropertyType
	::= ID
	;

private emptyStatement
	::= ';'
	;

ifStatement
	::= ifStatementStart elseIfStatement* elseStatement?
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
		]
		methods =[conditionalExpression = "/conditionExpression/expr" getBlockList]
	}
	;

private ifStatementStart
	::= 'if' conditionExpression statementOrBlock
	{
		pin=1
	}
	;

//@todo Replace with 'else' ifStatement instead of redeclaring whole block
elseIfStatement
	::= 'else' 'if' conditionExpression statementOrBlock
	{
		pin=2
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
		]
		methods =[conditionalExpression = "/conditionExpression/expr" getBlockList block="statementOrBlock"]
	}
	;

private elseStatement
	::= 'else' statementOrBlock
	{
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"]
		pin=1
		methods=[block="statementOrBlock"]
	}
	;

private iterationStatement
	::= doWhileStatement
    | 	whileStatement
    |	forStatement
    ;


doWhileStatement
	::= 'do' /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/ whileExpression eos?
	{
		pin=1
		//recoverWhile=inLoopRecoverWhile
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJIterationStatement"
		]
		methods =[
		 	getConditionalExpression
			getBlockList
			getBlock
		]
	}
	;

whileStatement
	::= whileExpression /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/
	{
		pin=1
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJConditionalStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJIterationStatement"

		]
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"]
		methods=[getBlockList conditionalExpression="/conditionExpression/expr" block="statementOrBlock"]
	}
	;

private whileExpression
	::= 'while' conditionExpression
	{
		methods =[
			getConditionalExpression = "/conditionExpression/expr"
		]
	}
	;

conditionExpression
	::= '(' expr ')'
	;

forStatement
	::= 'for' forLoopHeader  /*<<enterMode "inLoop">>*/ statementOrBlock /*<<exitMode "inLoop">>*/
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJIterationStatement"
		]
		methods = [
			getBlockList
			block="statementOrBlock"
		]
	}
	;

forLoopHeader
	::= '(' forLoopPartsInBraces ')'
	;

forLoopPartsInBraces
	::= compoundForLoopHeader
	|	inExpr
	;

private compoundForLoopHeader
	::= (variableDeclarationList|variableAssignmentSimple)? ';' expressionSequence ';' expressionSequence?
	;


varModifier
	::= 'var'
    | 	'let'
    | 	'const'
	;

private continueStatement
	::= 'continue' eos
	;

breakStatement
	::= 'break' eos
	{
		pin=1
	}
	;

returnStatement
	::= 'return' expr? eos
	{
		pin=1
	}
	;

private withStatement
	::= 'with' '(' expr ')' bodyStatement
	{
		pin=1
	}
	;

switchStatement
	::= 'switch' '(' expr ')' '{' switchBody '}'
	{
		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBraces"
		]
		methods=[getBlockList]
	}
	;

private switchBody
	::= caseClause* (defaultClause caseClause*)?
	;

caseClause
	::= 'case' expr ':' bracketLessBlock? 'break'?
	{
		pin=1
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
		methods=[getBlock getBlockList]
	}
	;

bracketLessBlock
	::= bodyStatement+
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJBlockMixin"
		methods= [getBlockList getIterationStatementList]
	}
	;

defaultClause
	::= 'default' ':' bracketLessBlock?
	{
		extends=caseClause
		implements="cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
		pin=1
		methods=[getBlock getBlockList]
	}
	;

throwStatement
	::= 'throw' expr eos
	{
		pin=1
	}
	;

tryStatement
	::= 'try' blockElement (catchProduction finallyProduction? | finallyProduction)
	{
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
		]
		methods = [getBlockList block="statementOrBlock" getBlock]
		pin=1
	}
	;

catchProduction
	::= 'catch' '(' variableName ')' blockElement
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"]
		methods=[block="statementOrBlock" getBlockList getBlock]
	}
	;

finallyProduction
	::= 'finally' blockElement
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"]
		methods=[block="statementOrBlock" getBlockList getBlock]
	}
	;

debuggerStatement
	::= 'debugger' eos
	;

deleteStatement
	::= 'delete' (qualifiedReference|'('qualifiedReference ')')
	;

functionDeclaration
	::= 'function' (<<notInMode "varDec">> functionName) formalParameterList blockElement
	{
		pin=2
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<ObjJFunctionDeclarationElementStub<ObjJFunctionDeclarationImpl>>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionDeclarationImpl>>"

			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionDeclarationImpl>"
		methods=[
			getName
			setName
			functionNameNode="/functionName"
			getFunctionNameAsString
			getParamNames
			getReturnType
			shouldResolve
			getBlockList
			createFoldingDescriptor
			getFormalParameterArgList
			getLastFormalParameterArg
			block="blockElement"
			getFunctionScope
		]

	}
	;

methodDeclaration
	::=  methodHeader methodBlock
	{
		pin=1
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
		]
		methods = [
			block="/methodBlock"
			getBlockList
			createTreeStructureElement
			createFoldingDescriptor
		]
	}
	;

methodHeader
	::= methodScopeMarker '(' (methodHeaderReturnTypeElement) ')' methodHeaderSelectorList
	{
		pin=1
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
			"com.intellij.psi.PsiNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodHeaderStub>"
		]
		methods = [
			getSelectorList
			getSelectorStrings
			getParamTypes
			getParamTypesAsStrings
			getSelectorString
			getName
			setName
			getReturnType
			getContainingClass
			getContainingClassName
			getMethodScope
			isStatic
			shouldResolve
			getContainingSuperClass
			isRequired
			createTreeStructureElement
		]
	}
	;

private methodHeaderSelectorList
	::= firstMethodDeclarationSelector methodDeclarationSelector* methodHeaderMultipleVariableTail?
	;

methodHeaderReturnTypeElement
	::= formalVariableType
	;

private methodHeaderMultipleVariableTail
	::= "," "..."
	;

methodScopeMarker
	::= '+'|'-'
	;

firstMethodDeclarationSelector
	::= selector (':' methodDeclarationSelectorVariable)?
	{
		pin=1
		extends=methodDeclarationSelector
		methods=[getVarType]
	}
	;

methodDeclarationSelector
	::= selector? ':' methodDeclarationSelectorVariable
	{
		pin=2;
		methods = [getVarType getContainingClassName getContainingClass getVarType getFileName getFormalVariableType]
	}
	;

private methodDeclarationSelectorVariable
	::= methodHeaderSelectorFormalVariableType variableName
	{
		pin(".*")=1
	}
	;

methodHeaderSelectorFormalVariableType
	::= ('(' (formalVariableType) ')')?;

implementationDeclaration
	::= implementationHeader <<enterMode "inImplementation" >> instanceVariableList? implementationElements? <<exitMode "inImplementation" >>'@end'
	{
		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJClassDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasIgnoreStatements"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJImplementationStub"
		methods = [
			isCategory
			getClassType
			getClassNameString
			getSuperClassName
			getCategoryNameString
			hasMethod
			getPresentation
			shouldResolve
			getUnimplementedProtocolMethods
			getAllUnimplementedProtocolMethods
			getMethodHeaders
			getInheritedProtocols
			createFoldingDescriptor
			createTreeStructureElement
			getTreeStructureChildElements
		]
	}
	;

private implementationElements
	::= implementationElement+
	{
		recoverWhile=recover_implementationElements
	}
	;

private recover_implementationElements
	::= !('@end'|possibleSourceElementStart)
	;

private implementationHeader
	::= '@implementation' className (implementationInheritanceDeclaration)?
	{
		pin=1
	}
	;

private implementationInheritanceDeclaration
	::= (categoryName |':' superClass)? (inheritedProtocolList)?
	;

superClass
	::= className
	;

categoryName
	::= '(' className ')'
	{
		methods = [
			categoryName="/className"
		]
	}
	;

inheritedProtocolList
	::= '<' protocolClassNamesList '>'
	{
		pin=1
		//recoverWhile = recoverInheritedAt
	}
	;

private protocolClassNamesList
	::= className (',' className)*
	{
		recoverWhile=recover_protocolClassNamesList
	}
	;

private recover_protocolClassNamesList
	::= !('>'|'{'|'@end'|atKeywords|ppKeywords)
	;

instanceVariableList
	::= '{' <<enterMode "implementationInstanceVariables">> instanceVariableListList? <<exitMode "implementationInstanceVariables">> '}'
	{
		pin=1;
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBraces"
		]
		methods=[createFoldingDescriptor]
	}
	;

private instanceVariableListList
	::= ( comment | preprocessorInstanceVariableListIfStatement | instanceVariableDeclaration)+
	{
		recoverWhile=recover_instanceVariableList
	}
	;
private recover_instanceVariableList
	::= !('}'|'+'|'-')
	;

private preprocessorStatement
	::= preprocessorIfStatement
	|	preprocessorDefineFunction
	|	preprocessorUndef
	|	preprocessorPragma
	| 	PP_WARNING stringLiteral LINE_TERMINATOR
	| 	PP_ERROR stringLiteral LINE_TERMINATOR
	|	PREPROCESSOR_DIRECTIVE
	;

preprocessorDefineFunction
	::= PP_DEFINE (functionName formalParameterList | variableName) <<enterMode "preprocessor">> preprocessorDefineBody <<exitMode "preprocessor">>LINE_TERMINATOR
	{
		pin=1;
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJPreprocessorDefineFunctionImpl>"
		methods=[
			getName
			setName
			functionNameNode="/functionName"
			getFunctionNameAsString
			getParamNames
			getReturnType
			shouldResolve
			block="preprocessorDefineBody"
			getBlockList
			getFormalParameterArgList
			getLastFormalParameterArg
			getIterationStatementList
			getFunctionScope
		]
	}
	;

preprocessorDefineBody
	::= preprocessorBodyStatementList|blockElement|expr ';'?
	{
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"]
		methods=[getBlockList getIterationStatementList getOpenBrace]
	}
	;

private preprocessorBodyStatementList
	::= bodyStatement+
	{
	}
	;

preprocessorUndef
	::= PP_UNDEF variableName LINE_TERMINATOR
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorPragma
	::= preprocessorPragmaMark
	|	PP_PRAGMA (ID|doubleQuoteStringLiteral)* LINE_TERMINATOR {
		pin(".*")=2
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorPragmaMark
	::= PP_PRAGMA 'mark'? PRAGMA_MARKER
	{
		pin=2;
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

preprocessorDefined
	::= PP_DEFINED ID
	{
		pin=1
		implements=["cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"]
	}
	;

private preprocessorInstanceVariableListIfStatement
	::= <<inMode "implementationInstanceVariables">> PP_IF  preprocessorIfCondition LINE_TERMINATOR  preprocessorInstanceVariableList (PP_ELSE_IF (preprocessorIfExpr ('||'|'&&' preprocessorIfExpr)*) LINE_TERMINATOR preprocessorInstanceVariableList )* (PP_ELSE LINE_TERMINATOR preprocessorInstanceVariableList)? PP_END_IF (<<eof>> | LINE_TERMINATOR)
	{
		pin=2
		extends=preprocessorIfStatement
	}
	;

preprocessorIfCondition
	::= preprocessorIfExpr ('||'|'&&' preprocessorIfExpr)*
	;

private recover_preprocessorIfCondition
	::= !(PP_IF|PP_ELSE_IF|PP_ELSE|PP_END_IF|LINE_TERMINATOR|)
	;

private preprocessorInstanceVariableList
	::= (comment|instanceVariableDeclaration|LINE_TERMINATOR)+
	{
		recoverWhile=recover_preprocessorIfCondition
	}
	;

private preprocessorIfExpr
	::= expr
	|	ID
	|	preprocessorDefined
	;

preprocessorIfStatement
	::=	PP_IF preprocessorIfCondition LINE_TERMINATOR preprocessorBodyStatements? (PP_ELSE_IF preprocessorIfCondition LINE_TERMINATOR preprocessorBodyStatements?)* (PP_ELSE LINE_TERMINATOR preprocessorBodyStatements?)? PP_END_IF LINE_TERMINATOR
	{
		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJPreprocessorStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatements"
		]
		methods=[
			getOpenBrace
			getBlockList
		];
	}
	;

preprocessorBodyStatements
	::= preprocessorBodyStatement+
	{
		recoverWhile=recover_preprocessorBodyStatements
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJChildrenRequireSemiColons"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJBlock"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJBlockMixin"
	}
	;

private recover_preprocessorBodyStatements
	::= !(PP_ELSE| PP_ELSE_IF|PP_END_IF)
	;

protocolDeclaration
	::= protocolHeader protocolBody '@end'
	{
		pin=1
		//recoverWhile=protocolRecoverDecWhile

		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJClassDeclarationElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJProtocolDeclarationMixin"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJProtocolDeclarationStub"
		methods=[
			getMethodHeaders
			hasMethod
			getPresentation
			shouldResolve
			getInheritedProtocols
			getClassNameString
			getClassType
			createFoldingDescriptor
			createTreeStructureElement
		]
	}
	;

private protocolBody
	::= <<enterMode "inProtocol" >> (preprocessorIfStatement|protocolSection)* <<exitMode "inProtocol" >>
	{
		recoverWhile=recover_classDec
	}
	;

private recover_classDec
	::= !(possibleSourceElementStart)
	;

private possibleSourceElementStart
	::= atKeywords|ppKeywords
	;

private protocolHeader
	::= '@protocol' className  inheritedProtocolList?
	{
		pin=1
	}
	;

private protocolSection
	::= protocolScopedMethodBlock
	|	protocolStatementList
	;

protocolScopedMethodBlock
	::= ('@optional'|'@required') protocolStatementList?
	{
		pin=1
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasTreeStructureElement"
		]
		methods=[createTreeStructureElement]
	}
	;

private protocolStatementList
	::= (protocolStatement eos)+
	{
		//recoverWhile=recover_protocolSection
	}
	;

private protocolStatement
	::= methodHeader
	| instanceVariableDeclaration
	;

private implementationElement
	::= preprocessorIfStatement
    | 	preprocessorStatement
    |	variableAssignmentSimple eos
    |	variableDeclaration eos
	| 	methodDeclaration
    | 	functionDeclaration
    |	comment
	;

typeDef
	::=	'@typedef' className
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJTypeDefStub"
		methods = [getClassNameString getMethodHeaders]
	}
	;

global
	::= '@global' variableName
	;

formalParameterList
	::= '(' formalParameterList_inner? ')';

private formalParameterList_inner
	::= formalParameterArg (',' formalParameterArg)* (',' lastFormalParameterArg)?
    | lastFormalParameterArg
    {
    	recoverWhile=recover_formalParameterList_inner
    }
	;

private recover_formalParameterList_inner
	::= !(')')
	;

formalParameterArg
	::= (UNDEFINED|variableName ('=' expr)?)
	{
		pin(".*")=1
		recoverWhile=recover_formalParameterArg
	}
	;

private recover_formalParameterArg
	::= !(','|')')
	;

lastFormalParameterArg
	::= '...' variableName
	;

arrayLiteral
	::= ('@['|'[') arrayLiteralExpressionList? ']' {
		pin=3
	}
	;

private arrayLiteralExpressionList
	::= (',')* (expr (',' expr?)*)?
	{
		recoverWhile=recover_arrayLiteralExpressionList
	}
	;

private recover_arrayLiteralExpressionList
	::= !(']'|'}'|';')
	;

objectLiteral
	::= ('@{'|'{') objectLiteralPropertiesList '}'
	|	('@{'|'{') '}'
	{
		pin(".*")=2
	 	//recoverWhile=recoverExprSequence
	 	implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBraces"
	 	]
	}
	;

private objectLiteralPropertiesList
	::= propertyAssignment (',' propertyAssignment?)*
	{
		recoverWhile=recover_objectLiteralPropertiesList
	}
	;

private recover_objectLiteralPropertiesList
	::= !('}')
	;

propertyAssignment
	::= propertyName (':') expr
	{
		pin=2
		//recoverWhile=recover_propertyAssignment
	}
	;

propertyName
	::= ID
	|	stringLiteral
    | 	integer
    |	variableName
	;

methodCall
	::= '[' callTarget !(','|']'|mathOp|assignmentOperator|'='|rightExpr) methodCallSelectorList ']'
	{
		pin=3
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasMethodSelector"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedReferenceComponent"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodCallStub>"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodCallStub"
		//recoverWhile = recover_methodCall
		methods = [getSelectorList getSelectorStrings getContainingClass getContainingClassName getContainingSuperClass getSelectorString getCallTargetText getPossibleCallTargetTypes singleSelector="/selector" shouldResolve getCallTargetText getQualifiedNameText getIndexInQualifiedReference]
	}
	;

private methodCallSelectorList
	::= qualifiedMethodCallSelector+
	|	selector ':'?
	{
		pin(".*")=1
		recoverWhile=recover_methodCallSelectorList
	}
	;
private recover_methodCallSelectorList
	::= !(']'|eos|keyword)
	;

qualifiedMethodCallSelector
	::= selector? ':' expr (',' expr)*
	{
		pin=2
	}
	;

selector
	::= 'with'
	| 	'delete'
	| 	'function'
	| 	'new'
	| 	ID
	|	'null'
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"com.intellij.navigation.NavigationItem"
		]
		methods=[setName getName getSelectorString getRangeInElement getReferences getContainingClass getContainingClassName getPresentation shouldResolve getContainingSuperClass getSelectorIndex getNameIdentifier]
	}
	;

classDependencyStatement
	::= '@class' className
	;

private expressionSequence
	::= expr (',' expr?)*
	{
		pin(".*")=1
		//recoverWhile=recover_expressionSequence
	}
	;


expr
	::= comment+ expr comment*
	|	prefixedExpr
 	|	leftExpr rightExpr*
 	|	leftExpr
    {
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNeedsSemiColon"
		]
		methods = [getBlock shouldResolve getBlockList]
		//recoverWhile=recover_statement
	}
	;

prefixedExpr
	::= ('!'|'~'|'-'|'+') expr;

leftExpr
	::= incrementExpr
	|	refExpression
	|	variableDeclaration
	|	functionCall
    |	methodCall
    | 	newExpression
	|	variableAssignmentLogical
	|	derefExpression
    |	qualifiedReference
    |	objectLiterals
    |	primary
	| 	parenEnclosedExpr
	|	typeOfExprPrime
    |	regularExpressionLiteral
	;

refExpression::= '@ref' '(' variableName ')';
derefExpression::='@deref' '(' variableName ')';
newExpression::= 'new' (functionCall|expr arguments?) ;

parenEnclosedExpr
	::= '(' expr? ')'
	{
		pin=1
	}
	;
private incrementExpr
	::= ('--'|'++') qualifiedReference
   	| 	qualifiedReference ('++'|'--')
	;

functionCall
	::= (functionName|methodCall) arrayIndexSelector* arguments
	{
		pin=3
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedReferenceComponent"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionCallElement"
			//"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		methods=[getQualifiedNameText getIndexInQualifiedReference getExprList getCloseParen getOpenParen]

	}
	;

arguments
	::= '(' expressionSequence? ')'
	;

rightExpr
	::= qualifiedReferencePrime
	| 	ternaryExprPrime
	| 	instanceOfExprPrime
	| 	logicExprPrime
	|	mathExprPrime
	|	comparisonExprPrime
	|	arguments
	|	parenEnclosedExpr
	|   arrayIndexSelector
	//|	assignmentExprPrime
	| 	inExprPrime
	;


instanceOfExprPrime
	::= 'instanceof' qualifiedReference
	;

typeOfExprPrime
	::= 'typeof' ('('expr')'|expr)
	;

inExpr
	::= varModifier? variableName 'in' expr
	;

inExprPrime
	::= 'in' expr
	;

logicExprPrime
	::= logicOperators expr
	;

private logicOperators
	::= '||'
	|	'&&'
	;

comparisonExprPrime
	::= comparisonOperators expr
	;

ternaryExprPrime
	::= '?' expr ':' expr
	{
		methods = [ifTrue="/expr[0]" ifFalse="/expr[1]"]
	}
	;


private comparisonOperators
	::= '<'|'>'|'<='|'>='|'=='|'==='|'!='|'!=='
	;

assignmentExprPrime
	::= assignmentOperator expr
	;

mathExprPrime
	::= mathOp expr
	;

mathOp
	::= '+'|'-'|MULTIPLY|'/'|'%'|'<<'|'>>'|'<<<'|'>>>'|'^'|'~'|'&'|'|'
	;

assignmentOperator
	::= '*='
    | 	'/='
    | 	'%='
    | 	'+='
    | 	'-='
    | 	'<<='
    | 	'<<<='
    | 	'>>='
    | 	'>>>='
    | 	'&='
    | 	'^='
    | 	'|='
	;

primary
	::= BOOLEAN_LITERAL
	| 	stringLiteral
	| 	numericLiteral
	| 	nullLiterals
	;

nullLiterals
	::= 'null'
	| 	'nil'
	| 	'undefined'
	;

formalVariableType
	::= varTypeId
	| VAR_TYPE_CHAR
	| VAR_TYPE_BYTE
	| VAR_TYPE_SHORT
	| VAR_TYPE_INT
	| VAR_TYPE_LONG_LONG
	| VAR_TYPE_LONG
	| VAR_TYPE_FLOAT
	| VAR_TYPE_DOUBLE
	| VAR_TYPE_IBOUTLET
	| VAR_TYPE_IBACTION
	| VAR_TYPE_BOOL
	| VAR_TYPE_SEL
	| VAR_TYPE_UNSIGNED
	| VAR_TYPE_SIGNED
	| <<notInMode "implementationInstanceVariables">> (VOID|AT_ACTION)
	| className
	;

varTypeId
	::= 'id' ('<' varTypeIdClassName '>')?
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVarTypeIdStub>"
		]
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVarTypeIdStub"
		methods=[getIdType shouldResolve]
	}
	;
private varTypeIdClassName
	::= className
	{
		pin=1
		recoverWhile=recover_varTypeIdClassName
	}
	;
private recover_varTypeIdClassName
	::= !('>'|')'|';'|'@accessors')
	;

private objectLiterals
	::=	arrayLiteral
    | 	objectLiteral
    |	functionDeclaration
    | 	functionLiteral
    | 	selectorLiteral
    | 	protocolLiteral
    /*| 	REGULAR_EXPRESSION_LITERAL_TOKEN_LITERAL*/
	;

functionLiteral
	::= 'function' formalParameterList blockElement
	{
		pin=1
		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJFunctionDeclarationElementStub<cappuccino.ide.intellij.plugin.psi.impl.ObjJFunctionLiteralImpl>"
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFoldable"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasBlockStatement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJFunctionDeclarationElement<ObjJFunctionDeclarationElementStub<ObjJFunctionLiteralImpl>>"
		]
		methods = [
			getFunctionNameNode
			getFunctionNameAsString
			getFunctionNamesAsString
			getReturnType
			getParamNameElements
			getParamNames
			getFunctionNameNode
			shouldResolve
			getBlockList
			createFoldingDescriptor
			getFormalParameterArgList
			getLastFormalParameterArg
			block="blockElement"
			getFunctionScope
		]
	}
	;

selectorLiteral
	::= '@selector' '(' selectorLiteralSelectorList ')'
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub>"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub>"
		]
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJSelectorLiteralStub"
		methods=[getReference getSelectorStrings getContainingClass getContainingClassName getSelectorString isStatic getMethodScope getReturnType shouldResolve getContainingSuperClass]
	}
	;

protocolLiteral
	::= '@protocol' '(' className ')'
	;

private selectorLiteralSelectorList
	::= (selector ':')* selector?
	;

private numericLiteral
	::= DECIMAL_LITERAL
    | 	integer
	;

integer
	::=	HEX_INTEGER_LITERAL
  	| 	OCTAL_INTEGER_LITERAL
   	|	OCTAL_INTEGER_LITERAL2
   	| 	BINARY_INTEGER_LITERAL
   	| 	INTEGER_LITERAL
   	;

regularExpressionLiteral
	::= REGULAR_EXPRESSION_LITERAL_TOKEN
	;

callTarget
	::= functionCall
	|	qualifiedReference
    | 	expr
    {
    	methods=[getPossibleCallTargetTypes]
	}
	;

qualifiedReference
	::= (variableName|methodCall|parenEnclosedExpr) qualifiedReferencePrimary*
	{
		methods = [
			primaryVar ="/variableName[0]"
			getLastVar
			getPartsAsString
			getPartsAsStringArray
			getQualifiedNameParts
		]
	}
	;

qualifiedReferencePrime
	::= '.' qualifiedReference
	;

private qualifiedReferencePrimary
	::= '.' (functionCall|variableName)
	|	arrayIndexSelector
	;

arrayIndexSelector
	::= '[' expr ']'
	{
		//pin = 1
		implements = [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedReferenceComponent"
		]
		methods = [
			getIndexInQualifiedReference
		]
	}
	;

stringLiteral
	::= doubleQuoteStringLiteral | singleQuoteStringLiteral
	{
		methods=[getStringValue]
	}
	;


private keyword
	::= BREAK
    | 	DO
    | 	INSTANCE_OF
    | 	TYPE_OF
    | 	CASE
    | 	ELSE
    | 	NEW
    | 	VAR
    | 	CATCH
    | 	FINALLY
    | 	RETURN
    | 	VOID
    | 	CONTINUE
    | 	FOR
    | 	SWITCH
    | 	WHILE
    | 	DEBUGGER
    | 	FUNCTION
    | 	THIS
    | 	WITH
    | 	DEFAULT
    | 	IF
    | 	THROW
    | 	DELETE
    | 	IN
    | 	TRY
    | 	CONST
    | 	LET
	;

className
	::= ID
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJClassNameStub"
		name="class name"
		implements= [
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		methods = [getReference getReferences getName setName getPresentation]
	}
	;

variableName
	::= ID
	|	'this'
	| 	VAR_TYPE_CHAR
	| 	VAR_TYPE_BYTE
	| 	VAR_TYPE_SHORT
	| 	VAR_TYPE_INT
	| 	VAR_TYPE_LONG
	| 	VAR_TYPE_FLOAT
	| 	VAR_TYPE_DOUBLE
	| 	VAR_TYPE_IBOUTLET
	| 	VAR_TYPE_IBACTION
	| 	VAR_TYPE_BOOL
	| 	VAR_TYPE_SEL
	| 	VAR_TYPE_UNSIGNED
	| 	VAR_TYPE_SIGNED
	{

		extends="cappuccino.ide.intellij.plugin.psi.impl.ObjJStubBasedElementImpl<?>"
		stubClass="cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVariableNameStub"
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJQualifiedReferenceComponent"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJResolveableElement<cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJVariableNameStub>"
		]
		methods = [toString getReference getRangeInElement getRangeInElement getName setName hasText getContainingClass getContainingClassName getQualifiedNameText shouldResolve getContainingSuperClass getIndexInQualifiedReference]
	}
	;

functionName
	::= ID
	{
		implements=[
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJCompositeElement"
			"cappuccino.ide.intellij.plugin.psi.interfaces.ObjJNamedElement"
		]
		methods = [getName setName getReference shouldResolve getIndexInQualifiedReference]
	}
	;

doubleQuoteStringLiteral
	::= ("\""|"@\"") QUO_TEXT? "\""
	{
		pin=2
	}
	;

singleQuoteStringLiteral
	::= "'" QUO_TEXT? "'"
	{
		pin=2
	}
	;

private eos
	::= <<lineTerminatorAhead>> ';'?
	|	<<notLineTerminator>> ';'
	|	'}'
    ;

fragment
	::= PP_FRAGMENT | AT_FRAGMENT
	;

private atKeywords
	::= '@typedef'|'@implementation'|'@class'|'@import'|'@protocol'|'@global'|'@end'
	;

private ppKeywords
	::= PP_IF|PP_ELSE|PP_ELSE_IF|PP_DEFINE|PP_END_IF|PP_WARNING|PP_ERROR|PP_PRAGMA
	;

