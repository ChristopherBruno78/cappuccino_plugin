package org.cappuccino_project.ide.intellij.plugin.references;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.TextRange;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiElementResolveResult;
import com.intellij.psi.PsiPolyVariantReferenceBase;
import com.intellij.psi.ResolveResult;
import org.cappuccino_project.ide.intellij.plugin.indices.ObjJClassInstanceVariableAccessorMethodIndex;
import org.cappuccino_project.ide.intellij.plugin.indices.ObjJMethodFragmentIndex;
import org.cappuccino_project.ide.intellij.plugin.indices.ObjJSelectorInferredMethodIndex;
import org.cappuccino_project.ide.intellij.plugin.indices.ObjJUnifiedMethodIndex;
import org.cappuccino_project.ide.intellij.plugin.psi.*;
import org.cappuccino_project.ide.intellij.plugin.psi.interfaces.ObjJHasContainingClass;
import org.cappuccino_project.ide.intellij.plugin.psi.interfaces.ObjJHasMethodSelector;
import org.cappuccino_project.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration;
import org.cappuccino_project.ide.intellij.plugin.psi.types.ObjJClassType;
import org.cappuccino_project.ide.intellij.plugin.utils.ObjJMethodCallPsiUtil;
import org.cappuccino_project.ide.intellij.plugin.utils.ObjJPsiImplUtil;
import org.cappuccino_project.ide.intellij.plugin.utils.ObjJTreeUtil;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ObjJSelectorReferenceBack extends PsiPolyVariantReferenceBase<ObjJSelector> {

    private final String selector;
    private final ObjJHasMethodSelector parent;
    private final String selectorUpToSelf;
    private final String fullSelector;
    private final int selectorIndex;
    private List<String> classConstraints;

    public ObjJSelectorReferenceBack(ObjJSelector element) {
        super(element, TextRange.create(0, element.getTextLength()));
        selector = element.getText();
        parent = ObjJTreeUtil.getParentOfType(element, ObjJHasMethodSelector.class);
        selectorIndex = parent != null ? parent.getSelectorStrings().indexOf(selector) : -1;
        fullSelector = parent != null ? parent.getSelectorString() : null;
        selectorUpToSelf = ObjJPsiImplUtil.getSelectorUntil(element, false);
        //LOGGER.log(Level.INFO, "Creating selector resolver for selector <"+fullSelector+">; Selector up to and including self <"+selectorUpToAndSelf+">");
    }

    @NotNull
    private List<String> getClassConstraints() {
        if (classConstraints != null) {
            return classConstraints;
        }
        ObjJMethodCall methodCall = ObjJTreeUtil.getParentOfType(myElement, ObjJMethodCall.class);
        if (methodCall == null) {
         //   LOGGER.log(Level.INFO, "Selector is not in method call.");
            return classConstraints;
        }

        classConstraints = ObjJMethodCallPsiUtil.getCallTargetTypes(methodCall.getCallTarget(), true);
        if (!classConstraints.isEmpty()) {
            //LOGGER.log(Level.INFO, "Call target: <"+methodCall.getCallTarget().getText()+"> is possibly of type: ["+ArrayUtils.join(classConstraints, ", ", false)+"]");
        } else {
         //   LOGGER.log(Level.INFO, "Failed to infer call target type for target named <"+methodCall.getCallTarget().getText()+">.");
        }
        return classConstraints;
    }

    @NotNull
    @Override
    public Object[] getVariants() {
     //   LOGGER.log(Level.INFO, "GetVariants");
        Collection<ObjJMethodHeader> headers = ObjJMethodFragmentIndex.getInstance().get(selectorUpToSelf, myElement.getProject());
        int selectorIndex = parent.getSelectorList().indexOf(myElement);
        if (selectorIndex < 0) {
            selectorIndex = 0;
        }
        List<ObjJSelector> results = new ArrayList<>();
        for (ObjJMethodHeader header : headers) {
            final List<ObjJSelector> selectors = header.getSelectorList();
            if (selectors.isEmpty()) {
                continue;
            }
            if (selectors.size() > selectorIndex) {
                results.add(header.getSelectorList().get(selectorIndex));
            }
        }
        return results.toArray();
    }

    /*
        @Nullable
        @Override
        public PsiElement resolve() {
         //   LOGGER.log(Level.INFO, "Resolving Selector");
            ResolveResult[] result = multiResolve(false);
            return result.length > 0 ? result[0].getElement() : null;
        }
    */
    @Override
    public boolean isReferenceTo(
            @NotNull
                    PsiElement element) {
        //LOGGER.log(Level.INFO, "Checking if selector is reference to.");
        if (element instanceof ObjJMethodHeader) {
            final ObjJMethodHeader methodHeader = (ObjJMethodHeader) element;
            if (methodHeader.getSelectorString().equals(fullSelector)) {
                return sharesContainingClass(getClassConstraints(), methodHeader);
            }
            //return methodHeader.getSelectorString().equals(selectorUpToAndSelf);
        }
        return false;
    }

    @NotNull
    @Override
    public ResolveResult[] multiResolve(boolean b) {
        //LOGGER.log(Level.INFO, "Resolving Selector <"+fullSelector+">");
        if (fullSelector == null) {
            return ResolveResult.EMPTY_ARRAY;
        }
        if (parent instanceof ObjJMethodHeader || parent instanceof ObjJAccessorProperty) {
            return PsiElementResolveResult.createResults(myElement);
        }

        List<ObjJMethodHeaderDeclaration> methodHeaders = ObjJUnifiedMethodIndex.getInstance().get(fullSelector, getProject());
        List<PsiElement> result;
        if (!methodHeaders.isEmpty()) {
            result = new ArrayList<>(prune(methodHeaders));
        } else {
            result = new ArrayList<>(getSelectorLiteralReferences());
        }
        for (ObjJInstanceVariableDeclaration variableDeclaration : ObjJClassInstanceVariableAccessorMethodIndex.getInstance().get(fullSelector, getProject())) {
            if (sharesContainingClass(getClassConstraints(), variableDeclaration)) {
                result.add(variableDeclaration.getAtAccessors() != null ? variableDeclaration.getAtAccessors() : variableDeclaration);
            }
        }

        if (result.isEmpty()) {
         //   LOGGER.log(Level.INFO, "Resolving selector <"+fullSelector+"> failed.");
            //methodHeaders = ObjJUnifiedMethodFragmentIndex.getInstance().get(selectorUpToAndSelf, getProject());
            return ResolveResult.EMPTY_ARRAY;
        }
        return PsiElementResolveResult.createResults(result);
    }

    private List<ObjJSelector> prune(List<ObjJMethodHeaderDeclaration> methodHeaders) {
        final List<String> classConstraints = getClassConstraints();
        final List<ObjJSelector> result = new ArrayList<>();
        final List<ObjJSelector> others = new ArrayList<>();
        for (ObjJMethodHeaderDeclaration methodHeader : methodHeaders) {
            ObjJSelector selectorElement = selectorIndex >= 0 ? methodHeader.getSelectorList().get(selectorIndex) : ObjJPsiImplUtil.findSelectorMatching(methodHeader, this.selector);
            if (selectorElement != null && sharesContainingClass(classConstraints, methodHeader)) {
                result.add(selectorElement);
            } else {
                others.add(selectorElement);
            }
        }

        if (result.size() > 1) {
            for (ObjJSelector selector : new ArrayList<>(result)) {
                if (ObjJTreeUtil.getParentOfType(selector, ObjJAccessorProperty.class) != null) {
                    result.remove(selector);
                }
            }
        }
        return !result.isEmpty() ? result : others;
    }

    private boolean sharesContainingClass(List<String> classConstraints, ObjJHasContainingClass hasContainingClass) {
        return classConstraints.isEmpty() || classConstraints.contains(ObjJClassType.UNDETERMINED) || classConstraints.contains(hasContainingClass.getContainingClassName());
    }

    private List<ObjJSelector> getSelectorLiteralReferences() {
        List<ObjJSelector> result = new ArrayList<>();
        List<ObjJSelectorLiteral> selectorLiterals = ObjJSelectorInferredMethodIndex.getInstance().get(fullSelector, getProject());
        for (ObjJSelectorLiteral selectorLiteral : selectorLiterals) {
            ObjJSelector selectorElement = selectorIndex >= 0 ? selectorLiteral.getSelectorList().get(selectorIndex) : ObjJPsiImplUtil.findSelectorMatching(selectorLiteral, this.selector);
            if (selectorElement != null) {
                result.add(selectorElement);
            }
        }
        return result;
    }

    private Project getProject() {
        return myElement.getProject();
    }
}
