package cappuccino.ide.intellij.plugin.psi.utils;

import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.project.IndexNotReadyException;
import cappuccino.ide.intellij.plugin.indices.ObjJClassDeclarationsIndex;
import cappuccino.ide.intellij.plugin.indices.ObjJUnifiedMethodIndex;
import cappuccino.ide.intellij.plugin.psi.*;
import cappuccino.ide.intellij.plugin.psi.interfaces.ObjJMethodHeaderDeclaration;
import cappuccino.ide.intellij.plugin.psi.types.ObjJClassType;
import cappuccino.ide.intellij.plugin.psi.utils.ObjJExpressionReturnTypeUtil.ExpressionReturnTypeReference;
import cappuccino.ide.intellij.plugin.psi.utils.ObjJExpressionReturnTypeUtil.ExpressionReturnTypeResults;
import cappuccino.ide.intellij.plugin.stubs.interfaces.ObjJMethodCallStub;
import cappuccino.ide.intellij.plugin.utils.ArrayUtils;
import cappuccino.ide.intellij.plugin.utils.ObjJInheritanceUtil;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import static cappuccino.ide.intellij.plugin.psi.types.ObjJClassType.UNDEF_CLASS_NAME;
import static cappuccino.ide.intellij.plugin.psi.types.ObjJClassType.UNDETERMINED;
import static cappuccino.ide.intellij.plugin.psi.types.ObjJClassType.isPrimitive;

public class ObjJMethodCallPsiUtil {

    private static final Logger LOGGER = Logger.getLogger(ObjJMethodCallPsiUtil.class.getName());
    private static final String GET_CLASS_METHOD_SELECTOR = ObjJMethodPsiUtils.getSelectorString("class");
    private static final String GET_SUPERCLASS_METHOD_SELECTOR = ObjJMethodPsiUtils.getSelectorString("superclass");
    public static final String IS_KIND_OF_CLASS_METHOD_SELECTOR = ObjJMethodPsiUtils.getSelectorString("isKindOfClass");

    public static String getSelectorString(ObjJMethodCall methodCall) {
        ObjJMethodCallStub stub = methodCall.getStub();
        if (stub != null) {
            LOGGER.log(Level.INFO, "Getting method call selector string from stub: <"+stub.getSelectorString()+">");
            return stub.getSelectorString();
        }
        return ObjJMethodPsiUtils.getSelectorStringFromSelectorStrings(methodCall.getSelectorStrings());
    }

    public static List<String> getReturnTypes(
            @NotNull
                    ObjJMethodCall methodCall, boolean validateCallTarget) {
        final ObjJCallTarget callTarget = methodCall.getCallTarget();
        List<String> callTargetTypes;
        if (validateCallTarget) {
            //noinspection ConstantConditions
            callTargetTypes = getCallTargetTypes(callTarget, false);
        } else {
            callTargetTypes = Collections.singletonList(ObjJClassType.UNDETERMINED);
        }
        if (methodCall.getSelectorString().equals(GET_SUPERCLASS_METHOD_SELECTOR)) {
            return Collections.singletonList(ObjJClassType.CLASS);
        }
        List<String> possibleReturnTypes = new ArrayList<>();
        String selector = methodCall.getSelectorString();
        /*if (selector.equals(GET_SUPERCLASS_METHOD_SELECTOR)) {
            for (String callTargetType : callTargetTypes) {
                for (ObjJClassDeclarationElement classDec : ObjJClassDeclarationsIndex.getInstance().get(callTargetType, methodCall.getProject())) {
                    if (classDec instanceof ObjJImplementationDeclaration) {
                        String superClass = ObjJClassDeclarationPsiUtil.getSuperClassName((ObjJImplementationDeclaration) classDec);
                        if (superClass != null && !possibleReturnTypes.contains(superClass)) {
                            possibleReturnTypes.add(superClass);
                        }
                    } else if (!possibleReturnTypes.contains(callTargetType)) {
                        possibleReturnTypes.add(callTargetType);
                    }
                }
            }
            return possibleReturnTypes;
        }*/
        //ProgressIndicatorProvider.checkCanceled();
        if (DumbService.getInstance(methodCall.getProject()).isDumb()) {
            throw new IndexNotReadyException();
        }
        String callTargetArrayString = "["+ ArrayUtils.join(callTargetTypes)+"]";
        for (ObjJMethodHeaderDeclaration methodHeader : ObjJUnifiedMethodIndex.getInstance().get(selector, methodCall.getProject())) {
            if (!ObjJMethodPsiUtils.isClassMethod(methodHeader, callTargetTypes)) {
             //   LOGGER.log(Level.INFO, "Method "+selector+"> does not match any inferred type: "+callTargetArrayString+". Class is <"+methodHeader.getContainingClassName()+">");
                continue;
            } else {
             //   LOGGER.log(Level.INFO, "Method "+selector+"> matches selector in inferred class <"+methodHeader.getContainingClassName()+">");
            }
            String returnType = methodHeader instanceof ObjJMethodHeader ? ((ObjJMethodHeader)methodHeader).getReturnType(validateCallTarget) : methodHeader.getReturnType();
            if (!possibleReturnTypes.contains(returnType)) {
             //   LOGGER.log(Level.INFO, String.format("Adding possible type: <%s> to list of [%s]", returnType, ArrayUtils.join(possibleReturnTypes, ", ", false)));
                possibleReturnTypes.add(returnType);
            } else {
             //   LOGGER.log(Level.INFO, "Possible return types already contains class: <" + returnType + ">");
            }
        }
        return possibleReturnTypes;
    }

    /*
        @NotNull
        public static List<String> getCallTargetTypeFirstCome(ObjJCallTarget callTarget, boolean validateCallTarget) {
            if (!validateCallTarget) {
                return Collections.singletonList(ObjJClassType.UNDETERMINED);
            }
            String callTargetType = getCallTargetTypeSimple(callTarget, validateCallTarget);
            if (callTargetType == null) {
                return Collections.emptyList();
            }
            List<String> out = new ArrayList<>();
            allInheritedClassesForAllPossibleTypes(out, callTargetType, callTarget.getProject());
         //   LOGGER.log(Level.INFO, String.format("CallTarget: <%s> has possible types of <%s>", callTarget.getText(), ArrayUtils.join(out, ", ", false)));
            return out;
        }
    */
    @NotNull
    public static List<String> getCallTargetTypes(ObjJCallTarget callTarget, boolean validateCallTarget) {
        if (!validateCallTarget) {
            return Collections.emptyList();
        }
        List<String> callTargetTypes;
        //noinspection ConstantConditions
        callTargetTypes = getCallTargetTypesSimple(callTarget, validateCallTarget);
     //   LOGGER.log(Level.INFO, String.format("CallTarget: <%s> has preliminary types of <%s>", callTarget.getText(), ArrayUtils.join(callTargetTypes)));
        List<String> out = new ArrayList<>();
        for (String callTargetType : callTargetTypes) {
            ObjJInheritanceUtil.getInheritedClasses(out, callTargetType, callTarget.getProject());
        }
        if (out.contains(ObjJClassType.CLASS) && !out.contains(ObjJClassType.CPOBJECT)) {
            out.add(ObjJClassType.CPOBJECT);
        }
     //   LOGGER.log(Level.INFO, String.format("CallTarget: <%s> has possible types of <%s>", callTarget.getText(), ArrayUtils.join(out)));
        return out;
    }

    @NotNull
    public static String getCallTargetText(ObjJMethodCall methodCall) {
        if (methodCall.getStub() != null) {
            return methodCall.getStub().getCallTarget();
        }
        return  methodCall.getCallTarget().getText();
    }

    /*
        private static String getCallTargetTypeSimple(ObjJCallTarget callTarget, boolean validateCallTarget) {
            if (!validateCallTarget) {
                return ObjJClassType.UNDETERMINED;
            }
            if (callTarget.getExpr() != null && callTarget.getExpr().getLeftExpr() != null && callTarget.getExpr().getLeftExpr().getMethodCall() != null) {
                return getTargetTypeFromMethodCall(callTarget.getExpr().getLeftExpr().getMethodCall(), validateCallTarget);
            }
            if (!ObjJClassDeclarationsIndex.getInstance().get(callTarget.getText(), callTarget.getProject()).isEmpty()) {
                return callTarget.getText();
            }
            if (callTarget.getExpr() != null) {
                return ObjJVarTypeResolveUtil.getExpressionReturnType(callTarget.getExpr(), validateCallTarget);
            }
            if (callTarget.getQualifiedReference() != null) {
                return getCallTargetTypeFromQualifiedReference(callTarget.getQualifiedReference(), validateCallTarget);
            }
            return null;
        }
    */
    private static List<String> getCallTargetTypesSimple(ObjJCallTarget callTarget, boolean validateCallTarget) {
        if (!validateCallTarget) {
            return Collections.singletonList(ObjJClassType.UNDETERMINED);
        }
        List<String> possibleTypes = new ArrayList<>();
        //ProgressIndicatorProvider.checkCanceled();
        if (!DumbService.isDumb(callTarget.getProject()) &&
                callTarget.getQualifiedReference() != null &&
                callTarget.getQualifiedReference().getFirstChild() instanceof ObjJVariableName &&
                !ObjJClassDeclarationsIndex.getInstance().get(callTarget.getQualifiedReference().getText(), callTarget.getProject()).isEmpty()) {
            return Collections.singletonList(callTarget.getText());
        }

        if (callTarget.getExpr() != null) {
         //   LOGGER.log(Level.INFO, "getCallTargetTypesSimple->ObjJVarTypeResolveUtil.getExpressionReturnTypes(<"+callTarget.getExpr().getText()+">)");
            //noinspection ConstantConditions
            ExpressionReturnTypeResults results = ObjJExpressionReturnTypeUtil.getReturnTypes(callTarget.getExpr());
            if (results != null) {
                for (ExpressionReturnTypeReference result : results.getReferences()) {
                    possibleTypes.add(result.getType());
                }
            }
        }

        if (callTarget.getQualifiedReference() != null) {
         //   LOGGER.log(Level.INFO, "getCallTargetTypesSimple->getCallTargetTypesFromQualifiedReference(<"+callTarget.getQualifiedReference().getText()+">)");
            //noinspection ConstantConditions
            possibleTypes.addAll(getCallTargetTypesFromQualifiedReference(callTarget.getQualifiedReference(), validateCallTarget));
        }
        return possibleTypes;
    }

    /*
        private static String getCallTargetTypeFromQualifiedReference(ObjJQualifiedReference qualifiedReference, boolean validateCallTarget) {
            if (!validateCallTarget) {
                return ObjJClassType.UNDETERMINED;
            }
            if (qualifiedReference.getMethodCall() != null) {
                return getTargetTypeFromMethodCall(qualifiedReference.getMethodCall(), validateCallTarget);
            }
            ObjJVariableName variableName = qualifiedReference.getLastVar();
            if (variableName == null) {
                variableName = qualifiedReference.getPrimaryVar();
            }
            if (variableName != null) {
                //LOGGER.log(Level.INFO, "Qualified reference has var name: <"+variableName.getText()+">");
                return ObjJVarTypeResolveUtil.getVarType(variableName, validateCallTarget);
            }/* else {
             //   LOGGER.log(Level.INFO, "Qualified reference has no var name.");
            }* /
            return null;
        }
    */
    private static List<String> getCallTargetTypesFromQualifiedReference(ObjJQualifiedReference qualifiedReference, boolean validateCallTarget) {
        if (!validateCallTarget) {
            return Collections.singletonList(ObjJClassType.UNDETERMINED);
        }
        if (qualifiedReference.getMethodCall() != null) {
         //   LOGGER.log(Level.INFO, "getCallTargetTypesFromQualifiedReference(<"+qualifiedReference.getText()+">)->getTargetTypesFromMethodCall(<"+qualifiedReference.getMethodCall().getText()+">)");
            //noinspection ConstantConditions
            return getReturnTypes(qualifiedReference.getMethodCall(), validateCallTarget);
        }
        if (!qualifiedReference.getArrayIndexSelectorList().isEmpty()) {
         //   LOGGER.log(Level.INFO, "Not yet able to infer array return types");
            return Collections.singletonList(ObjJClassType.UNDETERMINED);
        }
        ObjJVariableName variableName = qualifiedReference.getLastVar();
        if (variableName == null) {
            variableName = qualifiedReference.getPrimaryVar();
        }
        if (variableName != null) {
         //   LOGGER.log(Level.INFO, "getCallTargetTypesFromQualifiedReference(<"+qualifiedReference.getText()+">)->ObjJVarTypeResolveUtil.getVarTypes(<"+variableName.getText()+">)>");
            //noinspection ConstantConditions
            return ObjJVariableTypeResolveUtil.getVariableTypes(variableName, validateCallTarget);
        }/* else {
         //   LOGGER.log(Level.INFO, "Qualified reference has no var name.");
        }*/
        return Collections.emptyList();
    }

    @SuppressWarnings("unused")
    private static String getTargetTypeFromMethodCall(ObjJMethodCall methodCall, boolean validateCallTarget) {
        if (!validateCallTarget) {
            return ObjJClassType.UNDETERMINED;
        }
        final String selector = methodCall.getSelectorString();
        if (selector.equals(ObjJMethodPsiUtils.ALLOC_SELECTOR)) {
            final String allocReference = methodCall.getCallTarget().getText();
            if (allocReference.equals("self")) {
                return methodCall.getContainingClassName();
            }
            if (allocReference.equals("super") && methodCall.getContainingClass() instanceof ObjJImplementationDeclaration) {
                return ObjJClassDeclarationPsiUtil.getSuperClassName((ObjJImplementationDeclaration) methodCall.getContainingClass());
            }
            return allocReference;
        }
        //noinspection ConstantConditions
        final List<String> targetTypes = getCallTargetTypes(methodCall.getCallTarget(), validateCallTarget);
        //ProgressIndicatorProvider.checkCanceled();
        if (DumbService.getInstance(methodCall.getProject()).isDumb()) {
            throw new IndexNotReadyException();
        }
        for (ObjJMethodHeaderDeclaration methodHeader : ObjJUnifiedMethodIndex.getInstance().get(selector, methodCall.getProject())) {
            String returnType;
            if (methodHeader instanceof ObjJMethodHeader) {
                returnType = ((ObjJMethodHeader) methodHeader).getReturnType();
            } else {
                return methodHeader.getReturnType();
            }
            if ((targetTypes.isEmpty() || targetTypes.contains(methodHeader.getContainingClassName()))) {
                return returnType;
            } else {
             //   LOGGER.log(Level.INFO, String.format("TargetTypes IsEmpty?: <%b>; targetTypesContainsClass: <%b>; ReturnType <%s>", targetTypes.isEmpty(), targetTypes.contains(methodHeader.getContainingClassName()), returnType));
            }
        }
        return null;
    }

    private static List<String> getTargetTypesFromMethodCall(ObjJMethodCall methodCall, boolean validateCallTarget) {
        if (!validateCallTarget) {
            return Collections.singletonList(ObjJClassType.UNDETERMINED);
        }
        final String selector = methodCall.getSelectorString();
        if (selector.equals(ObjJMethodPsiUtils.ALLOC_SELECTOR)) {
            String allocReference = methodCall.getCallTarget().getText();
            if (allocReference.equals("self")) {
                allocReference = methodCall.getContainingClassName();
            }
            if (allocReference.equals("super") && methodCall.getContainingClass() instanceof ObjJImplementationDeclaration) {
                allocReference = ObjJClassDeclarationPsiUtil.getSuperClassName((ObjJImplementationDeclaration) methodCall.getContainingClass());
            }
            return Collections.singletonList(allocReference != null ? allocReference : ObjJClassType.UNDETERMINED);
        }
        //noinspection ConstantConditions
        final List<String> targetTypes = getCallTargetTypes(methodCall.getCallTarget(), validateCallTarget);
        if (selector.equals(GET_CLASS_METHOD_SELECTOR)) {
            return targetTypes;
        }
        if (selector.equals(GET_SUPERCLASS_METHOD_SELECTOR)) {
            List<String> result = new ArrayList<>();
            ObjJInheritanceUtil.getAllInheritedClassesForAllClassTypesInArray(result, targetTypes, methodCall.getProject());
            for (String superClass : new ArrayList<>(result)) {
                if (targetTypes.contains(superClass)) {
                    result.remove(superClass);
                }
            }
            return result;
        }
        final List<String> out = new ArrayList<>();
        //ProgressIndicatorProvider.checkCanceled();
        if (DumbService.getInstance(methodCall.getProject()).isDumb()) {
            throw new IndexNotReadyException();
        }
        for (ObjJMethodHeaderDeclaration methodHeader : ObjJUnifiedMethodIndex.getInstance().get(selector, methodCall.getProject())) {
            String returnType = methodHeader.getReturnType();
            if (ObjJMethodPsiUtils.isClassMethod(methodHeader, targetTypes) && !out.contains(returnType)) {
             //   LOGGER.log(Level.INFO, "Method <"+methodHeader.getText()+">has return type of: <"+returnType+">");
                if (isUniversalMethodCaller(returnType)) {
                    return Collections.singletonList(ObjJClassType.UNDETERMINED);
                }
                out.add(returnType);
            } else {
             //   LOGGER.log(Level.INFO, String.format("TargetTypes IsEmpty?: <%b>; targetTypesContainsClass: <%b>; ReturnType <%s>", targetTypes.isEmpty(), targetTypes.contains(methodHeader.getContainingClassName()), returnType));
            }
        }
        return targetTypes;
    }





    public static boolean isUniversalMethodCaller(@NotNull final String className) {
        return !isPrimitive(className) &&  (UNDETERMINED.equals(className) || UNDEF_CLASS_NAME.equals(className));
    }

    @NotNull
    public static List<String> getSelectorStrings(@NotNull ObjJMethodCall methodCall) {
        if (methodCall.getStub() != null && !methodCall.getStub().getSelectorStrings().isEmpty()) {
            return methodCall.getStub().getSelectorStrings();
        }
        return ObjJMethodPsiUtils.getSelectorStringsFromSelectorList(getSelectorList(methodCall));
    }

    @NotNull
    public static List<ObjJSelector> getSelectorList(@NotNull ObjJMethodCall methodCall) {
        if (methodCall.getSelector() != null) {
            return Collections.singletonList(methodCall.getSelector());
        }
        final List<ObjJSelector> out = new ArrayList<>();
        for (ObjJQualifiedMethodCallSelector qualifiedSelector : methodCall.getQualifiedMethodCallSelectorList()) {
            out.add(qualifiedSelector.getSelector());
        }
        return out;
    }




}
