/** The CDATASection interface represents a CDATA section that can be used within XML to include extended portions of unescaped text. The symbols < and & donâ€™t need escaping as they normally do when inside a CDATA section. */
class CDATASection extends Text {
    new();
}

/** The XMLDocument interface represent an XML document. It inherits from the generic Document and does not add any specific getMethods or properties to it: nevertheless, several algorithms behave differently with the two types of documents. */
class XMLDocument extends Document {
    new();
    addEventListener(type: K keyof DocumentEventMap, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener(type: K keyof DocumentEventMap, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}
/** The XMLSerializer interface provides the serializeToString() method to construct an XML string representing a DOM tree. */
class XMLSerializer {
    new();
    serializeToString(root: Node): string;
}

class XPathEvaluator {
    new();
    createExpression(expression: string, resolver: XPathNSResolver): XPathExpression;
    createNSResolver(nodeResolver?: Node): XPathNSResolver;
    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver | ((prefix: string) => string | null) | null, type: number, result: XPathResult | null): XPathResult;
}

/** An XPathExpression is a compiled XPath query returned from document.createExpression(). It has a method evaluate() which can be used to execute the compiled XPath. */
class XPathExpression {
    new();
    evaluate(contextNode: Node, type: number, result: XPathResult | null): XPathResult;
}

class XPathNSResolver {
    new();
    lookupNamespaceURI(prefix: string): string | null;
}

/** The XPathResult interface represents the results generated by evaluating an XPath 1.0 expression within the context of a given node. */
class XPathResult {
    new();
    static readonly ANY_TYPE: number;
    static readonly ANY_UNORDERED_NODE_TYPE: number;
    static readonly BOOLEAN_TYPE: number;
    static readonly FIRST_ORDERED_NODE_TYPE: number;
    static readonly NUMBER_TYPE: number;
    static readonly ORDERED_NODE_ITERATOR_TYPE: number;
    static readonly ORDERED_NODE_SNAPSHOT_TYPE: number;
    static readonly STRING_TYPE: number;
    static readonly UNORDERED_NODE_ITERATOR_TYPE: number;
    static readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;
    readonly booleanValue: boolean;
    readonly invalidIteratorState: boolean;
    readonly numberValue: number;
    readonly resultType: number;
    readonly singleNodeValue: Node;
    readonly snapshotLength: number;
    readonly stringValue: string;
    iterateNext(): Node;
    snapshotItem(index: number): Node;
    readonly ANY_TYPE: number;
    readonly ANY_UNORDERED_NODE_TYPE: number;
    readonly BOOLEAN_TYPE: number;
    readonly FIRST_ORDERED_NODE_TYPE: number;
    readonly NUMBER_TYPE: number;
    readonly ORDERED_NODE_ITERATOR_TYPE: number;
    readonly ORDERED_NODE_SNAPSHOT_TYPE: number;
    readonly STRING_TYPE: number;
    readonly UNORDERED_NODE_ITERATOR_TYPE: number;
    readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;
}

/** An XSLTProcessor applies an XSLT stylesheet transformation to an XML document to produce a new XML document as output. It has getMethods to load the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to apply the transformation to documents. */
class XSLTProcessor {
    new();
    clearParameters(): void;
    getParameter(namespaceURI: string, localName: string): any;
    importStylesheet(style: Node): void;
    removeParameter(namespaceURI: string, localName: string): void;
    reset(): void;
    setParameter(namespaceURI: string, localName: string, value: any): void;
    transformToDocument(source: Node): Document;
    transformToFragment(source: Node, document: Document): DocumentFragment;
}
